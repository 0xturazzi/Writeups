# ðŸŽ¯ Objetivo
Finalmente! Tudo isso para chegar no BOF SRP (classico) :D

Agora ta na hora de redirecionar o pointer para o nosso codigo malicioso (shellcode) para ganhar uma shell 
# ðŸ’¡ Dicas
A instruÃ§Ã£o "0xCC" serve para o debugger (como o gdb ou o do VsCode), quando a o rip chega nela a execuÃ§Ã£o pausa. Nos podemos usa-la para testar se conseguimos 
executar codigo, ou se o problema ta no shellcode: Se o debugger avisa que teve "SIGTRAP", nos temos execuÃ§Ã£o de cÃ³digo :D

Banco de dados de shellcode: [shell-storm](http://shell-storm.org/shellcode/files/)
# ðŸ”¥ Exploit
## Analisando o programa
main() printa o banner e chama start_level()

start_level(rbp-0x80) cria um buffer[**128**] e salva o output de gets() (**inseguro**)

Como vocÃª pode ver, nÃ£o exite comple_level()

Para completar, precisamos executar nosso prÃ³prio codigo (shellcode) e conseguir uma shell (uma linha de comando)
## Agora em ASM :D (analise estatica)
Primeiro, vamos ver main
```
gef> disassemble main
   0x00000000004005a4 <+0>:	push   rbp
   0x00000000004005a5 <+1>:	mov    rbp,rsp                       <- Prologo
   0x00000000004005a8 <+4>:	sub    rsp,0x10
   
   
   0x00000000004005ac <+8>:	mov    DWORD PTR [rbp-0x4],edi
   0x00000000004005af <+11>:	mov    QWORD PTR [rbp-0x10],rsi   <- args de puts
   0x00000000004005b3 <+15>:	mov    edi,0x400620
   0x00000000004005b8 <+20>:	call   0x400400 <puts@plt>        <- call puts
   
   
   0x00000000004005bd <+25>:	mov    eax,0x0                    <- args de start_level (nenhum)
   0x00000000004005c2 <+30>:	call   0x40058d <start_level>     <- call start_level
   
   
   0x00000000004005c7 <+35>:	mov    eax,0x0                    <- exit code (codigo de saida, 0=sem erro)
   0x00000000004005cc <+40>:	leave                             <- Epilogo
   0x00000000004005cd <+41>:	ret    
```
Agora vamos ver start_level
```
gef> disassemble start_level 
   0x000000000040058d <+0>:	push   rbp
   0x000000000040058e <+1>:	mov    rbp,rsp                  <- Prologo 
   0x0000000000400591 <+4>:	add    rsp,0xffffffffffffff80   <- Ignora esse ADD para nÃ£o se confundir,
                                                                  Normalmente usa SUB para alocar espaÃ§o na stack
   
   
   0x0000000000400595 <+8>:	lea    rax,[rbp-0x80]         <- rax = Pointer para buffer[128]
   0x0000000000400599 <+12>:	mov    rdi,rax                <- rdi = rax
   0x000000000040059c <+15>:	call   0x4003f0 <gets@plt>    <- call gets
   
   
   0x00000000004005a1 <+20>:	nop
   0x00000000004005a2 <+21>:	leave                         <- Epilogo
   0x00000000004005a3 <+22>:	ret    
```
Agora vamos adicionar um breakpoint!
> Breakpoint = ponto de pausa
>
> Antes daquela intruÃ§Ã£o ser executada, sera substituida por 0xCC. Isso faz o  debugger pausar a execuÃ§Ã£o do programa naquela instruÃ§Ã£o!
> Quando continuamos executando (normalmente o comando Ã© **continue**), o 0xCC Ã© substituido pela instruÃ§Ã£o certa :D
> 
> Se vocÃª esta fora de um debugger, 0xCC vai fazer o programa sair com erro
```
gef> b *0x000000000040059c
Breakpoint 1 at 0x40059c

"b" Ã© o comando do gdb para adionar um breakpoint
A "*" tem haver com aquele role dos pointers
O endereÃ§o Ã© para a "call gets" (olha la em cima)
```
> Dica: se vocÃª selecionar/sublinhar (clique esquerdo e passa o mouse em cima, vocÃª sabe do que eu to falando), e clicar o botÃ£o do meio no mouse (a rodinha) 
> o terminal automaticamente da Ctrl-C Ctrl-V naquele valor para vocÃª! EntÃ£o nÃ£o precisa copiar o endereÃ§o manualmente :D

## Agora vamos executar o programa (analise dinamica)
126 As nÃ£o causam erro, e 127 As causam... ue, mas pq? nÃ£o era pra dar erro sÃ³ em 128?
```
user@phoenix-amd64:/opt/phoenix/amd64$ python3 -c "print('A'*126)" | ./stack-five 
Welcome to phoenix/stack-five, brought to you by https://exploit.education

user@phoenix-amd64:/opt/phoenix/amd64$ python3 -c "print('A'*127)" | ./stack-five 
Welcome to phoenix/stack-five, brought to you by https://exploit.education
Segmentation fault
```
Isso vai ser muito importante no prÃ³ximo: buffers sÃ£o terminados com um null byte!

EntÃ£o pq eu to te ensinando isso agora? Resposta: SÃ³ por curiosidade!

SÃ³ que mais importantemente, isso nos mostra que o compilador nÃ£o adicionou nada no meio do caminho entre o buffer e o EBP+EIP Salvos :D

E nÃ³s ja sabemos como controlar o EIP, entÃ£o agora sÃ³ precisamos saber para onde redirecionar a execuÃ§Ã£o :)

## Encontrar endereÃ§o do buffer

Agora dentro do gdb (**gdb stack-five**)
> gef> r <<< $(python3 -c "print('A'*100)")
> 
> r Ã© o comand do gdb para rodar o programa!
>  Adicionando "<<<" nÃ³s podemos mandar uma string pro input! Tambem funciona com arquivos (sÃ³ 1 "<") :D

```
gef> r <<< $(python3 -c "print('A'*100)")
Starting program: /opt/phoenix/amd64/stack-five <<< $(python3 -c "print('A'*100)")
Welcome to phoenix/stack-five, brought to you by https://exploit.education

Breakpoint 1, 0x000000000040059c in start_level ()

--- Output do gef ---
--- gef Ã© uma extensÃ£o do gdb que vai te dar um monte de informaÃ§Ã£o util quando vocÃª chega num breakpoint ---
```
O output do gef contem:
![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/gef_example.png)
Porem, mais informaÃ§Ãµes podem ser adicionadas! use `gef> gef help` para ver como ele pode te ajudar :D 

Caso o programa seja executado sem breakpoints e com muitos As, vamos receber uma SIGSEV informando que "$PC"(outro nome para RIP) nÃ£o pode ser redirecionado para "41414141", confirmando que o nosso buffer overflow Ã© possivel (olha as linhas no final da segunda imagem)
![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20five/gef_A_overflow_0.png)
![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20five/gef_A_overflow_1.png)

Agora, vamos colocar o breakpoint em `call gets()` e executar o programa com o 140 As
![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20five/before_gets_0.png)

As partes importante no output do gef sÃ£o:

registers
![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20five/before_gets_3.png)

argumentos (vazio: o pointer em RDI aponta para **0x00007fffffffe5b0**, que possui o valor 0x0000...,)
![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20five/before_gets_1.png)

stack
![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20five/before_gets_2.png)

VocÃª tambem acha que tem uma falta de AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ?? hehehe :P

EntÃ£o vamos avanÃ§ar para prÃ³xima intruÃ§Ã£o (step: `s`) :D
![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20five/gef_after_gets_0.png)

Ah, assim que eu gosto XD

Isso quer dizer que aquele pointer dos argumentos agora aponta para os As, ne? Sim! :D
```
gef> x/s 0x00007fffffffe5b0              -> x/s Ã© o comando para printar strings
0x7fffffffe5b0:	'A' <repete 140 vezes>
``` 
EntÃ£o nos ja temos o endereÃ§o dos nossos As :D

## NOP sled
## Shellcode
# ðŸ’« SoluÃ§Ã£o
