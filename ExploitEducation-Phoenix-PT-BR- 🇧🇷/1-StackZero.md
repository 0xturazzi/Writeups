#Descrição:
Esse nivel demonstra que memoria pode ser acessada fora da sua região 
inicialmente alocada, como as variaveis são alocadas na stack, e que altera-las pode mudar a execução do programa.

#Objetivo: Alterar a variavel "changeme"

#Dica:
> $ python3 -c "print('A' * 10)"
> AAAAAAAAAA
> $ python3 -c "print('A' * 10)" | ./stack-zero 
> Welcome to phoenix/stack-zero, brought to you by https://exploit.education
> Uh oh, 'changeme' has not yet been changed. Would you like to try again?

#Explicação:
A função main() pode estar sendo divida em 3 Partes:
 1- Alocando as variaveis na stack (buffer[64], changeme)
 2- Alterar buffer[64] usando gets()
 3- Checando se changeme foi alterada

##1- Alocando as variaveis na stack (buffer[64], changeme)
A variavel buffer[64] tem  tamanho de 64 bytes (64 letras, assumindo ASCII).
A variavel changeme esta marcada como volátil para previnir que o compilador destrua ela (pq originalmente não seria
alterada, então seria destruida para otimizar o código. Mas nós vamos alterar ela por metodos... não convencionais hehehe).

A stack é uma porção da memoria que armazena como se fosse uma pilha de pratos: 
O primeiro a entrar, é o ultima a sair.
Quando você quer colocar um novo, você coloca no topo da pilha (push)
Quando você quer pegar um da pilha, você pega o do topo (pop)

Imagem da wikipedia mostrando PUSH e POP:
https://upload.wikimedia.org/wikipedia/commons/b/b4/Lifo_stack.png

A stack cresce para valores menores. Por exemplo:
  Imagina que ela é um poço que começa na profundidade 15.
  Quando você coloca algo de tamanho 2 na pilha, vai estar apoiado na profundidade 15, e vai até a profundidade 13.
  Em seguida, você coloca algo de tamanho 3, vai estar apoiado na profundidade 13, e vai até a profundidade 0.
Conforme você vai adicionando itens, o endereço que eles estão vai diminuindo em valor.
É meio confuso, mas com o tempo você pega o jeito.

Pra complicar um pouco mais, esses endereços tão em hexadecimal (0x0 ate 0xF, o "0x" é pra representar que o valor tá em hex).
Se vc não souber hex: https://pt.wikipedia.org/wiki/Sistema_de_numera%C3%A7%C3%A3o_hexadecimal
Mas resumindo, em hex você conta:
Hex: 0,1,2,...,8,9,A ,B ,C ,D ,E ,F ,10,11,12,...,19,1A,1B,1C,...,FF
Dec: 0,1,2,...,8,9,10,11,12,13,14,15,16,17,18,...,25,26,27,28,...,127

Então a base da stack é 0xFFFF e o topo 0X0000

Voltando ao exemplo do poço:
0x0- Topo da stack/Topo do poço
0xA ate 0x1- espaço vazio
0xD- Segundo item
0xF- Base da stack/Fundo do poço, primeiro item

Se quiser ler mais sobre a stack (inglês): [Wikipedia: Stack Based Memory Allocation](https://en.wikipedia.org/wiki/Stack-based_memory_allocation) 

Voltando ao execicio, nosas duas variaveis (buffer[64] e changeme) são empurradas na stack.
**_Stack:
buffer[64]
changeme (com o valor: 0)
ret       - Base dessa stack_**

2- Alterar buffer[64] usando gets
A função gets() abre um input no terminal, e escreve oq recebeu em um buffer.
O problema é que ela não checa se o valor é maior que o buffer, permitindo que 
você escreva fora do buffer.
Ela vai começar a escrever no topo do buffer (menor endereço) e vai descendo até a base da stack.
Nesse caso, alteraria o valor de "changeme"

Stack:
buffer
      [
A           | Gets escreve nesse sentido
A           |
A           \/
...
A
      ]
ret       - Base dessa stack

então, caso colocassemos 100 "A"s no buffer de tamanho 64, as variaveis nos proximos 36 endereços seriam alteradas.
Essas variaveis ficariam com o valor "41", mas pq? O valor ASCII do "A" é 0x41, você pode checar o de todas letras usando:
$ man ascii
Ui, perigoso ne?
É por isso que essa função está deprecada (fora de uso).

No nosso caso, o buffer tem o tamanho de 64 bytes, se colocarmos 65 "A"s (65 bytes), o valor vai vazar desse buffer.
Isso quer dizer que antes a variavel changeme tinha o valor "0x00" e agora tem o valor "0x41" !

Stack:
buffer
      [
41           | Gets escreve nesse sentido
41           |
41           \/
...
41
      ]
changeme (com o valor: 41)
ret       - Base dessa stack

3- O programa checa se changeme foi alterada, se foi, é vitoria :D

Ta, mas como a gente faz isso na prática?
$ python3 -c "print("A"*65)" printa 65 "A"s
Então se a gente encaminhar esses "A"s pro programa....
64 As, changeme não alterado:
user@phoenix-amd64:/opt/phoenix/amd64$ python3 -c "print('A' * 64)" | ./stack-zero 
Welcome to phoenix/stack-zero, brought to you by https://exploit.education
Uh oh, 'changeme' has not yet been changed. Would you like to try again?

65 As, changeme alterado:
user@phoenix-amd64:/opt/phoenix/amd64$ python3 -c "print('A' * 65)" | ./stack-zero 
Welcome to phoenix/stack-zero, brought to you by https://exploit.education
Well done, the 'changeme' variable has been changed!


Pras demonstrar melhor essa coisa do buffer escrever em um sentido (pq é muito importante), vou dar outro exemplo:
python3 -c "print('A' * 64 + 'B')" | ./stack-zero 
64 As e um B (0x42): AAAAAAAAA.....AAAB

Stack:
buffer
      [
41           | Gets escreve nesse sentido
41           |
41           \/
...
41
      ]
changeme (com o valor: 42)
ret       - Base dessa stack

Então os As preenchem certinho a stack, e a gente pode colocar o valor que quiser na variavel!! Uhhuuu :D
Esses As só pra encher a stack são chamados de "padding" (traduz pra preenchimento).

Fim! :D

Ouch... isso foi um bocado de explicação, mas relaxa que daqui pra frente fica mais dificil hehehe :D
Se você chegou até aqui, você ta de parabens !!!
Tira um tempinho pra descansar a cabeça que isso foi beeeem abstrato...
Pra lembrar bem, desenha uma stack no papel, da um push nas variaveis e no buffer, mostra o sentido que o 
buffer escreve, e ele vazando e mudando o valor das outras variaveis...


Solução:
$ python3 -c "print('A' * 65)" | ./stack-zero
Welcome to phoenix/stack-zero, brought to you by https://exploit.education
Well done, the 'changeme' variable has been changed!
