# ğŸ¯ Objetivo
O buffer overflow (BOF) vai nos permitir alterar o saved return pointer (SRP) e redirecionar a execuÃ§Ã£o do programa.

Esse desafio estÃ¡ nos preparando para o prÃ³ximo, no qual nos redirecionaremos a execuÃ§Ã£o para o nosso prÃ³prio cÃ³digo, e teremos um exploit de verdade! :D

Esse tipo de exploit era viÃ¡vel nos anos 90, quando mecanismos de proteÃ§Ã£o nÃ£o existiam. Por isso Ã© chamado de buffer overflow clÃ¡ssico (ou SRP BOF, se vocÃª gosta de siglas)! :D

Se vocÃª souber inglÃªs, vale a pena dar uma lida nesse post de 1996 no Phrack: [Smashing The Stack For Fun And Profit](http://phrack.org/issues/49/14.html) !

# ğŸ›¸ Conhecimento preliminar
Se tem uma seÃ§Ã£o inteira dedicada a conhecimento preliminar, eu posso te garantir que vai ser BASTANTE ! Verifique que o cinto de seguranÃ§a estÃ¡ firme e travado,
e mantenha as mÃ£os, pernas e canecas de cafÃ© dentro do veÃ­culo durante todo o percurso!

3...2...1....

## ğŸ¤– Assembly
Recursos adicionais:
[x64 Cheat Sheet - PDF](https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf&ved=2ahUKEwiPvJn2xvrsAhXIILkGHdA4BNUQFjAAegQIARAB&usg=AOvVaw384MVXQDBtyM1pPW3LeZrW)
[Harvard CS61](https://cs61.seas.harvard.edu/site/2018/Asm1/)
[Wikipedia Registers](https://en.m.wikipedia.org/wiki/Processor_register)
[GPR in 8086](https://www.tutorialspoint.com/general-purpose-registers-in-8086-microprocessor#:~:text=The%20general%20purpose%20registers%20are,has%20eight%20general%20purpose%20registers.&text=This%20is%20the%20accumulator.,into%20two%208%2Dbit%20registers) 
[Registradores - IntroduÃ§Ã£o Engenharia Reversa](https://mentebinaria.gitbook.io/engenharia-reversa/assembly/registradores)


Eu pretendo fazer uma serie de tutorias dedicada Ã  assembly (ASM), porÃ©m isso Ã© para o futuro...

Eu vou usar sintaxe intel, pq Ã© a melhor e se alguem te disser o contrÃ¡rio, a pessoa ta mentindo >:( !!!!

> ASM Ã© uma representaÃ§Ã£o legivel dos 0s e 1s das instruÃ§Ãµes do computador. 
> Ela pode ser transformada em machine code (cÃ³digo de maquina, os 0s e 1s) usando uma ferramenta chamada assembler!

EntÃ£o como vocÃª pode imaginar, Ã© bem complicado, e a minha maneira de explicar pode nÃ£o funcionar para vocÃª... EntÃ£o vai com calma, le de outras fontes, assite 
videos,... vai demorar um bom tempo pra ficar intuitivo, e ta tudo bem com isso :) vai no seu ritmo

### ğŸ“¦ Register (Registros / Registradores)
> Registers sÃ£o pedaÃ§os de memÃ³ria que ficam dentro do chip do processador, semelhante a memÃ³ria RAM, porÃ©m extremamente rÃ¡pidos e pequenos. O seu tamanho Ã© um dos determinantes da arquitetura (32 bits = register de 4 bytes, 64 bits = register de 8 bytes)
Esses registers sÃ£o semelhantes Ã  variÃ¡veis, no sentido que armazenam valores, podem ser alterados e lidos.

#### ğŸŒ General Purpose Registers (GPR) ( Registro de PropÃ³sito Geral )
Obs: muitos desses podem ser divididos em 2 partes, com metade do tamanho original. Nesse caso, se adiciona o sufixo H (High, A parte de cima) e L (Low, A parte de baixo). 
> Por exemplo: AX (16 bits, endereÃ§os: 0 a 15) (uma versÃ£o antiga do RAX) pode ser dividido em AL (8 bits, do 0 ao 7) e AH (8 bits, do 8 ao 15).

O propÃ³sito deles costuma ser, mas nÃ£o exclusivamente Ã©:
```
RAX: Acumulador   -> Usado para operaÃ§Ãµes lÃ³gicas ou aritmÃ©ticas 
RBX               -> Pointer para dados
RCX: Contagem     -> Usado em loops e outras operaÃ§Ãµes cÃ­clicas 
RDX: Dados        -> MultiplicaÃ§Ã£o, input/output
R8 a 15           -> vocÃª sÃ³ precisa saber que eles existem
```
Alem disso, sÃ£o usados para passar os argumentos para funÃ§Ãµes (explicaÃ§Ã£o em breve)
#### ğŸ’« Address Register ( armazenam endereÃ§os da stack )
```
RSP: Stack Pointer       -> Aponta para o topo da stack
RBP: Base Pointer        -> Aponta para a base da stack
RIP: Instruction Pointer -> Aponta para a instruÃ§Ã£o que estÃ¡ sendo executada 
```

#### ğŸ RFLAG
O register RFLAG armazena flags: sinais que indicam resultados passados . Esses sinais sÃ£o 1 bit (0 ou 1)
```
Exemplos:

PosiÃ§Ã£o    Nome         DescriÃ§Ã£o 
0          Carry         Resultado estourou o limite de um inteiro sem sinal (o "vai-um" da matemÃ¡tica)
6          Zero          A operaÃ§Ã£o resultou em 0, usada em comparaÃ§Ãµes
11         Overflow      Estourou o limite de um inteiro com sinal
```
#### ğŸ§  ApÃªndice - Curiosidade : Nomenclatura histÃ³rica
![](https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Ftse3.mm.bing.net%2Fth%3Fid%3DOIP.kkrG2L61YUbGLxwv5UcoPQHaFj%26pid%3DApi&f=1)
Eu vou usar o RAX como exemplo!
```
Em computadores 8 bits, ele era chamado A (Acumulador)
Em computadores 16 bits, ele era chamdo AX (Acumulador eXtendido ) 
Em computadores 32 bits, ele era chamado EAX e tem o tamanho de 2 AXs
Em computadores 64 bits, ele Ã© chamado RAX e tem o tamanho de 2 EAXs

Para propositos de retro-compatibilidade, nos ainda podemos usar, por exemplo, EAX em um computador 64 bits
Por tras das cenas, o computador interpreta EAX como a segunda metade do RAX

EntÃ£o nÃ£o estranhe caso alguem fale de EIP numa arquitetura x64, pois na linguagem informal nÃ£o faz diferenÃ§a
Mas caso vocÃª vÃ¡ analisar o register em um debugger, a diferenÃ§a importa :D
```

### âš¡ InstruÃ§Ãµes
> Obs: os registers foram usados aleatoriamente, pois seu propÃ³sito na realidade nÃ£o Ã© relevante para a explicaÃ§Ã£o !

As instruÃ§Ãµes sÃ£o o que o processador executa, por exemplo
``` 
add 0x4 0x1     -> adiÃ§Ã£o 4 + 1 = 5
```
Na sintaxe intel, o "alvo" da operaÃ§Ã£o vem primeiro e o "parÃ¢metro" depois

Caso os dois argumentos da instruÃ§Ã£o sejam valores, a operaÃ§Ã£o executara normalmente

Caso o **alvo** seja um **register**, o **resultado** da operaÃ§Ã£o serÃ¡ salvo nele 
``` 
add 0x4 0x1     -> adiÃ§Ã£o 4 + 1 = 5
add rbp 0x10    -> rbp  vira  rbp + 0x10
add rbp 0x22    -> Adiciona 0x22 ao rbp 
```

```
sub 0x4 0x1     -> subtraÃ§Ã£o 4 - 1 = 3
                 Caso fosse ao contrÃ¡rio a ordem "alvo" "parÃ¢metro",
                 o resultado seria `-3` !
                 
sub rbp 0x10    -> rbp  vira  rbp - 0x10
sub rsp 0x10    -> Subtrai 0x10 de rsp
```

Algumas outras instruÃ§Ãµes que serÃ£o importantes
```
push -> Empurra o valor pro topo da Stack

pop  -> Tira o valor no topo da Stack e salva no alvo
     |---> pop      -> SÃ³ remove o valor no topo da Stack
     |---> pop rbp  -> Remove o valor do topo e salva em rbp
      
mov  -> Move o valor do parÃ¢metro para o alvo
     |---> mov rbx 0x10   -> O valor de rbx vira 0x10
     |---> mov rbx rax    -> O valor de rbx vira o valor de rax
     |---> mov rax rbx    -> O valor de rax vira o valor de rbx

Usadas no epÃ­logo ( explicadas em breve )
           ret     -> retorna da funÃ§Ã£o ( em essÃªncia Ã© sÃ³ um "pop rip" )
           leave -> restaura o stack frame anterior ( mov rsp rbp ; pop rbp )

xor, and, ......  -> Operadores lÃ³gicos, tÃªm o mesmo comportamento de sub e add
                  |---> and rbp 0x10   -> rbp  vira  rbp & 0x10
                  |---> xor rsp 0x10   -> rsp  vira  rsp ^ 0x10

Jumps/Pulos
jmp 0x00001234 -> Move o RIP para aquela localizaÃ§Ã£o incondicionalmente, equivalente a um GOTO

test rax 0x1 ; jmpEQ 0x00001234 -> jmp equal
             |---> Compara os valores; Se forem iguais da o jump (normalmente usado em conjunto com a ZERO_FLAG)

jmpLE  -> jmp less or equal   -> Menor ou igual   â‰¤
jmpGE -> jmp greater or equal -> Maior ou igual   â‰¥
```
Caso vc nÃ£o saiba os operadores lÃ³gicos: [Wikipedia Operador LÃ³gico](https://pt.wikipedia.org/wiki/Operador_l%C3%B3gico)

### ğŸ¦„ FunÃ§Ãµes, PrÃ³logo e EpÃ­logo
Agora tÃ¡ na hora de aprender **realmente** como essa tal de stack funciona, entÃ£o Ã© bom dar uma revisada, nÃ©?
#### â˜• RevisÃ£o 
```
- A stack Ã© como uma pilha de pratos: Ãºltimo a entrar, primeiro a sair (LIFO)
- Ela cresce para valores menores: 
    - A memÃ³ria Ã© representada de cabeÃ§a pra baixo!
    - A base fica em um endereÃ§o maior (parte de baixo)
    - O topo fica em um endereÃ§o menor (parte de cima)
    - Portanto, a stack cresce em direÃ§Ã£o Ã  valores menores :D 

```
#### ğŸ–¼ï¸ Stack Frame ( Moldura da Stack )
VocÃª se lembra do RBP e RSP la da parte dos register? Eles ficam importantes agora! :D

O rbp indica a base da stack, e rsp o topo.

A regiÃ£o entre os dois Ã© chamada de stack frame: um pedaÃ§o da stack :D

A stack como um todo possui vÃ¡rios stack frames, porÃ©m sÃ³ um estÃ¡ ativo por vez (o indicado pelo rbp/rsp).

Para poder criar um novo ou destruir um antigo, existem procedimentos chamados PrÃ³logo e EpÃ­logo, respectivamente.

> Obs: Quando vocÃª muda o tamanho da stack por push/pop, o RSP se ajusta automaticamente 

Quando chamamos uma **funÃ§Ã£o()**, precisamos criar um frame novo para ela por meio de um PrÃ³logo, e salvar o endereÃ§o do frame atual. Ao retornar, esse frame serÃ¡ destruÃ­do com um EpÃ­logo e o antigo serÃ¡ restaurado !

Para a explicaÃ§Ã£o, vamos usar o seguinte pseudo-programa:
```
Fn print_dois(x, y) {
    print(x)
    print(y)

    return
}
Fn main() {
    x = "Ola! :D"
    y = "Assembly Ã© legal"

    print_dois(x, y)

    return
}
```
Agora vamos executar **main()**, **x** e **y** sÃ£o definidas e nos jÃ¡ sabemos como isso funciona, agora vamos chamar a funÃ§Ã£o, que Ã© aonde a mÃ¡gica acontece !
#### ğŸ”’ PrÃ³logo
- Se a funÃ§Ã£o recever argumentos, passar eles
Chamar a funÃ§Ã£o 
- Salvar o frame atual
- Criar novo frame
Executar a funÃ§Ã£o
##### Se a funÃ§Ã£o receber argumentos, salvar eles
Algumas arquiteturas passam os argumentos pela stack, salvando-os na stack na ordem inversa:
```
(x, y)
push y
push x
```
Mas comumente, os argumentos sÃ£o passados pelos registers:
```
RAX (Valor retornado)
RDI (1Âº parametro)
RSI (2Âº parametro)
RDX (3Âº parametro)
Tem para o resto, mas se a sua funÃ§Ã£o recebe mais de 3 parametros,
tem algo de errado e vocÃª precisa reescrever essa porcaria hehehe :P
```

> Caso **main()** use um desses registers, vai ser nescessÃ¡rio dar um push neles, e restaura-los no epilogo 
#### Salvar o frame atual
```
push RIP + 0x4 ; salva o RIP na stack, porÃ©m nÃ£o o valor atual, e sim o endereÃ§o da prÃ³xima instruÃ§Ã£o 
push RBP       ; salva o RBP
```
Atualmente, a stack estÃ¡ assim
```
rbp main            <- RSP   -
rip main                     | Frame de
                             | main()
... resto da stack  <- RBP   -
```
#### Criar novo frame
Agora, para criar um novo frame, precisamos subir o rbp atÃ© o rsp
```
mov rbp rsp ; Move o valor de rsp para rbp!
               Ou melhor : rbp "anda" atÃ© o rsp
```
Atualmente, a stack estÃ¡ assim
```
rbp main    <- RSP  e RBP apontam para a mesma localizÃ§Ã£o
rip main                   
... stack frame de main omitido           
```
Agora, precisamos **subtrair** de RSP para alocar espaÃ§o na memÃ³ria para essa funÃ§Ã£o 
> A stack cresce para valores menores :)
```
sub rsp - 0x20 ; vamos supor que, para esse exemplo, a funÃ§Ã£o precisa de 32 bytes.
                    Portanto, vamos subtrair 32 bytes de RSP, para faze-lo "subir"
```
Atualmente, a stack estÃ¡ assim
```
...          <- RSP      -
InstruÃ§Ãµes de print_dois |
...                      | Frame de
...                      | print_dois()
rbp main     <- RBP      -
rip main                   
...              
```
Com esse mÃ©todo de chamar funÃ§Ã£o, nÃ£o importa a localizaÃ§Ã£o da memÃ³ria de quando a funÃ§Ã£o foi chamada, ela sempre vai executar da mesma maneira

> Esse processo pode ocorrer muitas vezes caso uma funÃ§Ã£o chame outra, no nosso exemplo, um novo frame seria criado para **print()**, print seria executada,
> e o frame destruÃ­do ao retornar. Apos **print()** retornar, **print_dois continuara a execuÃ§Ã£o normalmente! :)**

```
O prologo entÃ£o pode ser resumido em

salvar vars
call
  push rip
  push rbp
  mov rbp rsp
  sub rsp 0x1234
  executar a funÃ§Ã£o
```

#### ğŸ”‘ EpÃ­logo 
O epilogo Ã© bem mais simples que o prologo:
```
- Devolver memoria e restaurar RBP    -> leave   
- Restaurar RIP  e retornar           -> ret
```

Atualmente, a stack estÃ¡ assim
```
...          <- RSP      -
InstruÃ§Ãµes               |
...                      | Frame de
...                      | print_dois()
rbp main     <- RBP      -
rip main                   
            
```
**leave**

Para devolver a memoria, precisamos mover RSP "para baixo: basta dar um `mov rsp rbp` ("andar" rsp atÃ© o rbp)

Atualmente, a stack estÃ¡ assim
```
...                    
InstruÃ§Ãµes          A regiÃ£o nÃ£o Ã© apagada, pois consumiria processamento a toa!         
...                 O valores ficam largados lÃ¡ atÃ© uma nova funÃ§Ã£o escrever por cima deles...
                    Por isso que, ao analisar a stack, as vezes vemos "lixo" aleatorio
                    Eles pode ser ignorado pois nem estÃ¡ mais na stack
                          
rbp main  <- RBP e RSP - O topo da stack
rip main                                
```
Em seguida, vamos restaurar o rbp de main `pop rbp` (remover o valor no topo da stack (ver acima por referencia), e colocalo no alvo: **rbp**)
```
--- omitido ---
rip main      <- RSP   (lembrando que RSP se ajusta automaticamente com push/pop)
...
... main
call print_dois
proxima instruÃ§Ã£o
... resto de main
ret da main   <- RBP
```

**ret (return)**
ret vai restaurar o EIP de main com um `pop rip`
```
...
... main          <- RSP
call print_dois
proxima instruÃ§Ã£o <- RIP
... resto de main
ret da main       <- RBP
```

Assim, o stack frame de main foi restaurado graÃ§as ao rbp e rip salvos ( o rip salvo Ã© chamado de **Saved Return Pointer (SRP)** )

# Caso vocÃª tenha viajado durante tudo isso, o que vocÃª precisa saber
Existem algumas variaveis especiais dentro do processador:
```
RSP: Stack Pointer       -> Aponta para o topo da stack
RBP: Base Pointer        -> Aponta para a base da stack
RIP: Instruction Pointer -> Aponta para a instruÃ§Ã£o que estÃ¡ sendo executada 
```

O RIP e o RBP atuais sÃ£o salvos na stack quando chamamos uma funÃ§Ã£o, junto das outras variaveis:
```
buffer[64]
uns int qualquer usado na funÃ§Ã£o
....
rbp
rip
```

Se por um buffer overflow conseguimos alterar aqueles inteiros, como **changeme** nos execicios anteriores, tambem conseguimos alterar RIP e redirecionar a execuÃ§Ã£o do programa!

# ğŸ”¥ Exploit
## ğŸ”¬ Analisar o programa
## ğŸ  Encontrar endereÃ§o de complete_level
## â‰ï¸ O compilador adicionou coisa???
## ğŸ”§ Ajustar o Exploit

# ğŸ’« SoluÃ§Ã£o
