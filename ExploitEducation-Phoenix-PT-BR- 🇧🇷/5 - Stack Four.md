# Objetivo
O buffer overflow (BOF) vai nos permitir alterar o return pointer (SRP) e redirecionar a execução do programa.

Esse desafio esta nos preparando para o próximo, no qual nos redirecionaremos a execução para o nosso próprio código, e teremos um exploit de verdade! :D

Esse tipo de exploit era viavel nos anos 90, quando mecanismos de proteção não existiam. Por isso é chamado de buffer overflow classico! :D

Se você souber inglês, vale a pena dar uma lida nesse post de 1996 no Phrack: [Smashing The Stack For Fun And Profit](http://phrack.org/issues/49/14.html) !

# Conhecimento preliminar
Se tem uma seção inteira dedicada a conhecimento preliminar, eu posso te garantir que vai ser BASTANTE ! Verifique que o cinto de segurança esta firme e travado,
e mantenha as mãos, pernas e canecas de café dentro do veiculo durante todo o percurso!

3...2...1....

## Assembly
Eu pretendo fazer uma serie de tutorias dedicada à assembly (ASM), porém isso é pra o futuro...

Eu vou usar sintaxe intel, pq é a melhor e se alguem te disser o contrário, a pessoa ta mentindo >:( !!!!

> ASM é uma representação legivel dos 0s e 1s das instruções do computador. 
> Ela pode ser transformada em machine code (código de maquina, os 0s e 1s) usando uma ferramenta chamada assembler!

### Register (Registros)

### Instruções
As instruções são o que o processor executa, por exemplo
``` 
add 0x4 0x1     -> adição 4 + 1 = 5
```
Na sintaxe intel, o "alvo" da operação vem primeiro e o "parametro" depois

Caso os dois argumentos da instrução sejam valores, a operação executara normalmente

Caso o *alvo* seja um *register*, o *resultado* da operação sera salvo nele 
``` 
add 0x4 0x1     -> adição 4 + 1 = 5
add rbp 0x10    -> rbp  vira  rbp + 0x10
add rbp 0x22    -> Adiciona 0x22 ao rbp 
```

```
sub 0x4 0x1     -> subtração 4 - 1 = 3
                 Caso fosse ao contrário a ordem "alvo" "parametro",
                 o resultado seria `-3` !
                 
sub rbp 0x10    -> rbp  vira  rbp - 0x10
sub rsp 0x10    -> Subtrai 0x10 de rsp
```

Algumas outras instruções que serão importantes
```
push -> Empurra o valor pro topo da Stack

pop  -> Tira o valor no topo da Stack e salva no alvo
     |---> pop      -> Só remove o valor no topo da Stack
     |---> pop rbp  -> Remove o valor do topo e salva em rbp
      
mov  -> Move o valor do parametro para o alvo
     |---> mov rbx 0x10   -> O valor de rbx vira 0x10
     |---> mov rbx rax    -> O valor de rbx vira o valor de rax
     |---> mov rax rbx    -> O valor de rax vira o valor de rbx

ret   -> retorna da função ( em essencia é só um "pop rip" )

leave

xor, and, ......  -> Operadores lógicos, tem o mesmo comportamento de sub e add
                  |---> and rbp 0x10   -> rbp  vira  rbp & 0x10
                  |---> xor rsp 0x10   -> rsp  vira  rsp ^ 0x10
```
Caso vc não saiba os operadores lógicos: [Wikipedia Operador Lógico](https://pt.wikipedia.org/wiki/Operador_l%C3%B3gico)

### Prologo e epilogo

# Exploit
## Analisar o programa
## Encontrar endereço de complete_level
## O compilador adicionou coisa???
## Ajustar o Exploit

# Solução
