# Explicação
## Analisando o programa
### main
```
int main(int argc, char **argv) {
  char *ptr;
  printf("%s\n", BANNER);

#ifdef NEWARCH
  if (argv[1]) {
    what = argv[1];
  }
#endif

  ptr = getenv("ExploitEducation");
  if (NULL == ptr) {
    // This style of comparison prevents issues where you may accidentally
    // type if(ptr = NULL) {}..

    errx(1, "Please specify an environment variable called ExploitEducation");
  }

  printf("%s\n", greet(ptr));
  return 0;
}
```
Main começa definindo um pointer (ptr) e printando o banner

Em seguida, faz verificaçõs relacionadas à arquitetura do sistema usando o diretivo:
`#ifdef NEWARCH`. O diretivo `#ifdef NOME` checa se a macro chamda `NOME` existe.

Isso é usado para tornar o incio da mensagem de boas vindas (gerada por greet) ser dependente da arquitetura!

Por isso nos não a encontramos no codigo fonte! Mas caso usemos `strings` conseguimos encontra-las no binario:
![Diferença entre as arquiteturas](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20six/Messages_ARCH.png)

Em seguida, main salva o valor da env var "ExploitEducation" no pointer ptr

Depois, é checado se ptr é NULL (a env var não existe)

Caso não exista: usa a função errx() para enterromper a execução com uma mensagem de erro! errx() recebe 2 argumento: (codigo_do_erro, mensagem_do_erro)

No nosso caso:
```
  ptr = getenv("ExploitEducation");
  if (NULL == ptr) {
    errx(1, "Please specify an environment variable called ExploitEducation");
  }
    // Codigo de erro: 1
   // Mensagem de erro: Por favor, especifique uma env var chamada ExploitEducation
```
Nos podemos confirmar isso usando: `echo $?`, que printa o codigo retornado pelo ultimo programa
![0 = sem erro, 1 = erro](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20six/Exit_Codes_errx.png)

> 0 = sem erro, 1 = erro

por ultimo, greet() é chamada, e o valor retornado por ela é printado!

E o programa finaliza retornando 0 (sem erro)!

#### Dica
Para definir uma env var no gdb

![set environment ExploitEducation=ABC](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20six/Exit_Codes_gdb.png)

### greet
```
char *greet(char *who) {
  char buffer[128];
  int maxSize;

  maxSize = strlen(who);
  if (maxSize > (sizeof(buffer) - /* ensure null termination */ 1)) {
    maxSize = sizeof(buffer) - 1;
  }

  strcpy(buffer, what);
  strncpy(buffer + strlen(buffer), who, maxSize);

  return strdup(buffer);
}
```
Agora chega a parte vulneravel! D:

greet recebe um argumento: "who" (quem recebe a mensagem de boas vindas)

São definidas duas variaveis locais: buffer[128] e maxSize (tamanho maximo)

O tamanho de who é salvo em maxSize

> Lembrete: Buffers são terminados com um NULL byte, portanto um buffer[128] só armazena 127 letras!

Em seguida, é checado se maxSize é maior que o tamanho(buffer) - 1 (-1 por causa no null byte final)

Caso seja maior, maxSize vai ser denifido como o tamanho(buffer) - 1 (maxSize = 127)

> Portando, o limite de maxSize é 127

Essa é uma tentativa de prevenir o buffer overflow! Pois, só seriam copiados 127 bytes, impedindo o overflow D:

Mas aqui que entra o problema: essa contagem não leva em consideração o inicio da mensagem (what)! Aquele que era dependente da arquitetura :D

Então nos vamos acabar escrevendo fora do buffer! Aqui esta a parte do codigo que causa a vulnerabilidade
```
strcpy(buffer, what); // what = incio da mensagem
strncpy(buffer, who, maxSize); // who = o valor de ExploitEducation! Quem recebe o oi :D
```
Nos ja sabemos como o strcpy funciona (você passa um buffer como alvo e o que vamos salvar nele, ignorando tamanho! Caso nos conseguissemos controlar what, poderiamos facilmente exploitar o programa)

str**N**cpy é similar a strcpy, mas recebe um terceiro parametro: tamanho!

Esse tamanho é limitado à 127 (limite de maxSize), então teoricamente não seria exploitavel :(

**Mas espera ai, ja tinha coisa naquele buffer!!! O inicio da mensagem!!!**

O tamanho do inicio é 34 bytes (na versão amd64)
```
$ python3
>>> x = "Welcome, I am pleased to meet you "
>>> len(x)
34
```

Isso quer dizer que no buffer cabem 128, mas foram colocados 34 + 127: Overflow!

Então se não fosse pelo inicio da mensagem, não seria exploitavel :D

Uma maneira de concertar essa vulnerabilidade seria: `strncpy(buffer, who, maxSize - sizeof(buffer))` (subtrair o tamanho atual)

## Analisando o programa (ASM)
### main
eu removi os endereços para caber na tela
```
gef> disassemble main
push   rbp
mov    rbp,rsp                    -> Prologo
sub    rsp,0x20


mov    DWORD PTR [rbp-0x14],edi
mov    QWORD PTR [rbp-0x20],rsi
mov    edi,0x400878
call   0x400530 <puts@plt>        -> printar o banner


mov    edi,0x4008c2               -> o 1º argumento é "ExploitEducation"
call   0x400520 <getenv@plt>      -> Le as env vars e coloca "ExploitEducation" em rax


mov    QWORD PTR [rbp-0x8],rax    -> Pointer para rax
cmp    QWORD PTR [rbp-0x8],0x0    -> Compara esse pointer com 0x0 
                                    (Teoricamente "cmp rax, 0x0" tambem deveria funcionar,
                                    mas salvando nesse pointer, podemos usar o valor depois)
jne    0x4007dd <main+66>         -> Jump not equal (pular se a comparação anterior for diferente)
                                    Mas pular para onde? Para main+66 (logo depois da mensagem de erro)
                                 Ou melhor: Caso ExploitEducation esteja definida, nos não emitimos erro

Essa parte só executa caso ExploitEducation não exista {
        mov    esi,0x4008d8               -> 2º argumento
        mov    edi,0x1                    -> 1º argumento
        mov    eax,0x0                    -> Valor retornado por main
        call   0x400540 <errx@plt>        -> Enterrompe a execução e sai com erro
}



        0x4007dd <main+66>:
mov    rax,QWORD PTR [rbp-0x8]      -> Lembra daquele pointer que salvamos com o rax de getenv() ? 
                                      Coloca ele em rax de novo :D
mov    rdi,rax                      -> 1º argumento: rax (o valor da env ExploitEducation)
call   0x4006fd <greet>             -> Chama greet()
   
mov    rdi,rax                      -> 1º argumento: O valor que greet retornou (salvo em rax)
call   0x400530 <puts@plt>          -> Printa a mensagem de boas vindas para o terminal
   
   
mov    eax,0x0                      -> Valor retornado por main: 0 (sem erro)
leave                               -> Epilogo
ret    
```

Não é tão relevante analisar o assembly de greet para entender a vulnerabilidade, dado que temos o codigo fonte!

Mas caso queira, você pode analisar por conta própria e relacionar o ASM com o codigo fonte por treino :D

## Fuzz

Agora que sabemos que é possivel realizar o overflow, vamos ver o que é corrompido :D

Nos só podemos colocar 127 no bytes no input, pois se colocarmos mais o programa simplesmente vai remove-los: então colocar 127 ou 200 teria o mesmo efeito! :)

Primeiro, vamos encontrar aonde colocaremos nossos breakpoints
```
gef> disassemble greet 
Dump of assembler code for function greet:
   0x00000000004006fd <+0>:	push   rbp
   0x00000000004006fe <+1>:	mov    rbp,rsp
   0x0000000000400701 <+4>:	push   rbx
   0x0000000000400702 <+5>:	sub    rsp,0xa8
.......
.......
   0x0000000000400798 <+155>:	pop    rbx
   0x0000000000400799 <+156>:	pop    rbp
   0x000000000040079a <+157>:	ret    
End of assembler dump
```

Vamos colocar uma no incio de greet e uma no final! :D
```
gef> b *0x4006fe 
Breakpoint 1 at 0x4006fe

gef> b *0x40079a
Breakpoint 2 at 0x40079a
```
E vamos rodar com 127 As: 

Obs: 

> gef> set environment ExploitEducation=$(python -c "print 'A' * 127")

Deveria funcionar, mas não funciona sei la por que :(

Então eu rodei

> python -c "print 'A' * 127"

Em outro terminal, e dei Ctrl+shift+C Ctrl+shift+V

> gef> set environment ExploitEducation=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Agora, vamos rodar o programa `r`. Quando ele chegar no breakpoint 1 (inicio de greet), pode analisar o frame e ver aonde esta rbp!
```
gef> info frame
Stack level 0, frame at 0x7fffffffe590:
 rip = 0x4006fe in greet; saved rip = 0x4007e9
 called by frame at 0x7fffffffe5c0
 Arglist at 0x7fffffffe580, args: 
 Locals at 0x7fffffffe580, Previous frame's sp is 0x7fffffffe590
 Saved registers:
  rbp at 0x7fffffffe580, rip at 0x7fffffffe588                            <- aqui
```

Agora que nos sabemos o endereço de RIP e RBP, podemos checar seu valores:
```
endereço: valor

gef> x/xg 0x7fffffffe580            -> rbp
0x7fffffffe580:	0x00007fffffffe5b0
gef> x/xg 0x7fffffffe588            -> rip
0x7fffffffe588:	0x00000000004007e9
```
> Obs: o /xg é só para a formatação ficar legivel! Significa eXtra Grande (que é o tamanho do pointer na arquitetura amd64)!

Isso quer dizer que no inicio de greet, os valores do RIP e RBP salvos na stack são: 0x00000000004007e9 e 0x00007fffffffe5b0

Agora vamos continuar a execução `c`, e ver se eles se alteram (lembrando greet é vulneravel)!

```
gef> c
---- output do gef ----
gef> x/xg 0x7fffffffe580             -> rbp
0x7fffffffe580:	0x00007fffffffe541
gef> x/xg 0x7fffffffe588             -> rip
0x7fffffffe588:	0x00000000004007e9
```
Eita! RBP foi alterado D:

> 0x00007fffffffe5**b0** --->  0x00007fffffffe5**41**

Isso quer dizer que nós conseguimos controlar o ultimos byte do rbp salvo! Esse ultimo byte constuma ser chamado de LSB (Least Significant Byte, Byte menos significante)

Assim, quer dizer que esse buffer overflow é um BoF que corrompe o LSB, ou como é mais conhecido: **off-by-one** (errado por um)!

Esse tipo de buffer overflow é bem comum: vão esquecer de que o buffer termina com um `0x00` e vão comparar o input com o tamanho do buffer, ao enves do tamanho do buffer - 1. Assim, permitindo que seja escrito 1 byte fora do buffer!

#### Curiosidade

Lembra que o texto no inicio do buffer varia de arquitetura para aquitetura? Isso acontece pois cada uma aloca as variaveis em uma posição, otimizam de maneira diferente, etcetc!

Muitas vezes um **off-by-one** não vai ser exploitavel, pois o byte que vem logo depois do buffer não nescessariamente é o rbp! E esse é o nosso caso: existem outras variaveis dentro de greet!

Assim, quem desenvolveu o desafio nos fez o favor de colocar essa mensagem no inicio para compensar esse espaço!

Caso a mensagem fosse 1 byte maior, poderiamos controlar 2 bytes do rbp! Caso a mensagem fosse 1 byte MENOR, não conseguiriamos controlar o rbp! E caso a mensagem fosse 4 bytes a mais, como você pode imaginar, poderiamos controlar o RIP :D

E caso o programa nem cheque o input? Ai facilita bastante pra gente hehe :D ! É o caso do desafio passado!

Assim, esse desafio foi feito de uma maneira que vá nos ensinar como exploitar um **off-by-one** que nos da **execução de codigo**

Na vida real, caso não existisse essa mensagem, só conseguiriamos exploitar esse off-by-one caso o nosso buffer estivesse adjacente ao rbp, isto é: não existe nenhuma outra variavel, ou o buffer foi alocado na parte mais baixa da stack(Do lado do RBP)!
```
Nesse caso, nós nao conseguiriamos alterar RBP nem RIP,
portanto seria impossivel conseguir execução de codigo :(

O maximo que conseguimos fazer é corromper 1 byte de uma varivel!
._ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _  _ .
|    buffer      |   outras variaveis     | RBP | RIP | 
|_ _ _ _ _ _ _ _ |_ _ _ _ _ _ _ _ _ _ _ _ |_ _ _|_ _ _|

O impacto disso varia muito: não acontecer nada (mais comum), fazer o programa crashar, ou alterar
um valor importante (por exemplo, aquela varivel poderia armazenar o seu saldo do banco hehe ;) )...
```

# Exploit
Agora que sabemos o tipo de exploit que precisamos escrever, basta seguir os passos a seguir:
1. Descobrir que partes da memoria controlamos
2. Encontrar para que região podemos apontar rbp
3. Encontrar um pointer nessa região que aponte para a parte que controlamos
## O que controlamos?
Normalmente, nos controlamos o input e as env vars, nesse caso o input é passado pelas env vars... portanto podemos falar que a unica região da memoria que
controlamos são as env vars

E qual é essa região? Vamos encontrar :D

### Setup
As envs são diferentes dentro do gdb, nós podemos comparar usando 

```
Fora do gdb: env
Dentro do dbg: show environment
```

A diferença é: gdb adiciona "LINES" e "COLUMNS", e " _ " (o programa sendo executando nesse momento, esta definido como "/usr/local/bin/gdb")
```
user@phoenix-amd64$ diff /tmp/gdb /tmp/env
16,18c16
< _=/usr/local/bin/gdb
< LINES=33
< COLUMNS=168
---
> _=/usr/bin/env
```
Para concertar essa diferença, e garantir que todos endereços estão certos, basta executar dentro do gdb:
```
unset environment COLUMNS
unset environment LINES
set environment _=/opt/phoenix/amd64/stack-six

> Aviso: Se você sair do gdb elas vão resetar!
```

### Descobrir que partes da memoria controlamos
Colocando um breakpoint no inicio de main (`b *main`), vamos encontrar registers apontando para envs!
![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20six/envs_gef.png)

Escolhendo o menor endereço e printando!

![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20six/envs_addr.png)

> Dica: vale a pena conferir se aquele realmente é o incio das envs, no nosso caso é :D

![](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20six/envs_addr2.png)

Isso quer dizer que as envs estão de: 0x7fffffffe817 (inclusivo) a 0x7fffffffeff8 (exclusivo)
