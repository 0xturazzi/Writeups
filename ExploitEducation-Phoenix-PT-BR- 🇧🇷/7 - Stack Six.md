## Analisando o programa
### main
Main começa definindo um pointer (ptr) e printando o banner

Em seguida, faz verificaçõs relacionadas à arquitetura do sistema usando o diretivo:
`#ifdef NEWARCH`. O diretivo `#ifdef NOME` checa se a macro chamda `NOME` existe.

Isso é usado para tornar o incio da mensagem de boas vindas (gerada por greet) ser dependente da arquitetura!

Por isso nos não a encontramos no codigo fonte! Mas caso usemos `strings` conseguimos encontra-las no binario:
![Diferença entre as arquiteturas](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20six/Messages_ARCH.png)

Em seguida, main salva o valor da env var "ExploitEducation" no pointer ptr

Depois, é checado se ptr é NULL (a variavel não existe)

Caso não exista: usa a função errx() para enterromper a execução com uma mensagem de erro! errx() recebe 2 argumento: (codigo_do_erro, mensagem_do_erro)

No nosso caso:
```
  ptr = getenv("ExploitEducation");
  if (NULL == ptr) {
    errx(1, "Please specify an environment variable called ExploitEducation");
  }
    // Codigo de err0: 1
   // Traduz para: Por favor, especifique uma env var chamada ExploitEducation
```
Nos podemos confirmar isso usando: `echo $?`, que printa o codigo retornado pelo ultimo programa
![0 = sem erro, 1 = erro](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20six/Exit_Codes_errx.png)

> 0 = sem erro, 1 = erro

por ultimo, greet() é chamada, e o valor retornado por ela é printado!

E o programa finaliza retornando 0 (sem erro)!

#### Dica
Para definir uma env var no gdb

![set environment ExploitEducation=ABC](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20six/Exit_Codes_gdb.png)

### greet
Agora chega a parte vulneravel! D:

greet recebe um argumento: "who" (quem recebe a mensagem de boas vindas)

São definidas duas variaveis locais: buffer[128] e maxSize (tamanho maximo)

O tamanho de who é salvo em maxSize

> Lembrete: Buffers são terminados com um NULL byte, portanto um buffer[128] só armazena 127 letras!

Em seguida, é checado se maxSize é maior que o tamanho(buffer) - 1 (-1 por causa no null byte final)

Caso seja maior, maxSize vai ser denifido como o tamanho(buffer) - 1 (maxSize = 127)

> Portando, o limite de maxSize é 127

Essa é uma tentativa de prevenir o buffer overflow! Pois, só seriam copiados 127 bytes, impedindo o overflow D:

Mas aqui que entra o problema: essa contagem não leva em consideração o inicio da mensagem (what)! Aquele que era dependente da arquitetura :D

Então nos vamos acabar escrevendo fora do buffer! Aqui esta a parte do codigo que causa a vulnerabilidade
```
strcpy(buffer, what); // what = incio da mensagem
strncpy(buffer, who, maxSize); // who = o valor de ExploitEducation! Quem recebe o oi :D
```
Nos ja sabemos como o strcpy funciona (você passa um buffer como alvo e o que vamos salvar nele, ignorando tamanho! Caso nos conseguissemos controlar what, poderiamos facilmente exploitar o programa)

str**N**cpy é similar a strcpy, mas recebe um terceiro parametro: tamanho!

Esse tamanho é limitado à 127 (limite de maxSize), então teoricamente não seria exploitavel :(

**Mas espera ai, ja tinha coisa naquele buffer!!! O inicio da mensagem!!!**

O tamanho do inicio é 34 bytes (na versão amd64)
```
$ python3
>>> x = "Welcome, I am pleased to meet you "
>>> len(x)
34
```

Isso quer dizer que no buffer cabem 128, mas foram colocados 34 + 127: Overflow!

Então se não fosse pelo inicio da mensagem, não seria exploitavel :D

Uma maneira de concertar essa vulnerabilidade seria: `strncpy(buffer, who, maxSize - sizeof(buffer))` (subtrair o tamanho atual)

## Analisando o programa (ASM)
### main
eu removi os endereços para caber na tela
```
gef> disassemble main
push   rbp
mov    rbp,rsp                    -> Prologo
sub    rsp,0x20


mov    DWORD PTR [rbp-0x14],edi
mov    QWORD PTR [rbp-0x20],rsi
mov    edi,0x400878
call   0x400530 <puts@plt>        -> printar o banner


mov    edi,0x4008c2               -> o 1º argumento é "ExploitEducation"
call   0x400520 <getenv@plt>      -> Le as env vars e coloca "ExploitEducation" em rax


mov    QWORD PTR [rbp-0x8],rax    -> Pointer para rax
cmp    QWORD PTR [rbp-0x8],0x0    -> Compara esse pointer com 0x0 
                                    (Teoricamente "cmp rax, 0x0" tambem deveria funcionar,
                                    mas salvando nesse pointer, podemos usar o valor depois)
jne    0x4007dd <main+66>         -> Jump not equal (pular se a comparação anterior for diferente)
                                    Mas pular para onde? Para main+66 (logo depois da mensagem de erro)
                                 Ou melhor: Caso ExploitEducation esteja definida, nos não emitimos erro

Essa parte só executa caso ExploitEducation não exista {
        mov    esi,0x4008d8               -> 2º argumento
        mov    edi,0x1                    -> 1º argumento
        mov    eax,0x0                    -> Valor retornado por main
        call   0x400540 <errx@plt>        -> Enterrompe a execução e sai com erro
}



        0x4007dd <main+66>:
mov    rax,QWORD PTR [rbp-0x8]      -> Lembra daquele pointer que salvamos com o rax de getenv() ? 
                                      Coloca ele em rax de novo :D
mov    rdi,rax                      -> 1º argumento: rax (o valor da env ExploitEducation)
call   0x4006fd <greet>             -> Chama greet()
   
mov    rdi,rax                      -> 1º argumento: O valor que greet retornou (salvo em rax)
call   0x400530 <puts@plt>          -> Printa a mensagem de boas vindas para o terminal
   
   
mov    eax,0x0                      -> Valor retornado por main: 0 (sem erro)
leave                               -> Epilogo
ret    
```


## Setup
As envs são diferentes dentro do gdb, nós podemos comparar usando 

```
Fora do gdb: env
Dentro do dbg: show environmente
```

A diferença é: gdb adiciona "LINES" e "COLUMNS", e " _ " (o programa sendo executando nesse momento), esta definido como "/usr/local/bin/gdb"
```
user@phoenix-amd64:/opt/phoenix/amd64$ diff /tmp/gdb /tmp/env
16,18c16
< _=/usr/local/bin/gdb
< LINES=33
< COLUMNS=168
---
> _=/usr/bin/env
```
Para concertar essa diferença, e garantir que todos endereços estão certos, basta executar dentro do gdb:
```
unset environment COLUMNS
unset environment LINES
set environment _=/opt/phoenix/amd64/stack-five
```
Depois você pode checar se estão iguais!

> Aviso: Se você sair do gdb elas vão resetar!
