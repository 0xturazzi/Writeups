## Analisando o programa
### main
Main começa definindo um pointer (ptr) e printando o banner

Em seguida, faz verificaçõs relacionadas à arquitetura do sistema usando o diretivo:
`#ifdef NEWARCH`. O diretivo `#ifdef NOME` checa se a macro chamda `NOME` existe.

Isso é usado para tornar o incio da mensagem de boas vindas (gerada por greet) ser dependente da arquitetura!

Por isso nos não a encontramos no codigo fonte! Mas caso usemos `strings` conseguimos encontra-las no binario:
![Diferença entre as arquiteturas](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/stack%20six/Messages_ARCH.png)
### greet
## Analisando o programa (ASM)
### main
eu removi os endereços para caber na tela
```
gef> disassemble main
push   rbp
mov    rbp,rsp                    -> Prologo
sub    rsp,0x20


mov    DWORD PTR [rbp-0x14],edi
mov    QWORD PTR [rbp-0x20],rsi
mov    edi,0x400878
call   0x400530 <puts@plt>        -> printar o banner


mov    edi,0x4008c2               -> o 1º argumento é "ExploitEducation"
call   0x400520 <getenv@plt>      -> Le as env vars e coloca "ExploitEducation" em rax


mov    QWORD PTR [rbp-0x8],rax    -> Pointer para rax
cmp    QWORD PTR [rbp-0x8],0x0    -> Compara esse pointer com 0x0 
                                    (Teoricamente "cmp rax, 0x0" tambem deveria funcionar,
                                    mas salvando nesse pointer, podemos usar o valor depois)
jne    0x4007dd <main+66>         -> Jump not equal (pular se a comparação anterior for diferente)
                                    Mas pular para onde? Para main+66 (logo depois da mensagem de erro)
                                 Ou melhor: Caso ExploitEducation esteja definida, nos não emitimos erro

Essa parte só executa caso ExploitEducation não exista {
        mov    esi,0x4008d8               -> 2º argumento
        mov    edi,0x1                    -> 1º argumento
        mov    eax,0x0                    -> Valor retornado por main
        call   0x400540 <errx@plt>        -> Enterrompe a execução e sai com erro
}



        0x4007dd <main+66>:
mov    rax,QWORD PTR [rbp-0x8]      -> Lembra daquele pointer que salvamos com o rax de getenv() ? 
                                      Coloca ele em rax de novo :D
mov    rdi,rax                      -> 1º argumento: rax (o valor da env ExploitEducation)
call   0x4006fd <greet>             -> Chama greet()
   
mov    rdi,rax                      -> 1º argumento: O valor que greet retornou (salvo em rax)
call   0x400530 <puts@plt>          -> Printa a mensagem de boas vindas para o terminal
   
   
mov    eax,0x0                      -> Valor retornado por main: 0 (sem erro)
leave                               -> Epilogo
ret    
```










## Setup
As envs são diferentes dentro do gdb, nós podemos comparar usando 

```
Fora do gdb: env
Dentro do dbg: show environmente
```

A diferença é: gdb adiciona "LINES" e "COLUMNS", e " _ " (o programa atualmente executando), esta definido como "/usr/local/bin/gdb"
```
user@phoenix-amd64:/opt/phoenix/amd64$ diff /tmp/gdb /tmp/env
16,18c16
< _=/usr/local/bin/gdb
< LINES=33
< COLUMNS=168
---
> _=/usr/bin/env
```
Para concertar essa diferença, e garantir que todos endereços estão certos, basta executar dentro do gdb:
```
unset environment COLUMNS
unset environment LINES
set environment _=/opt/phoenix/amd64/stack-five
```
Depois você pode checar se estão iguais!

>Aviso, se você sair do gdb elas vão resetar!
>
> Para muda-las permanentemente
