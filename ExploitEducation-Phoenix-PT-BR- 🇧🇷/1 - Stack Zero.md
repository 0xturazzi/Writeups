Index
1. [üìù Descri√ß√£o](https://github.com/0xturazzi/Writeups/blob/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/1%20-%20Stack%20Zero.md#-descri%C3%A7%C3%A3o)
2. [üéØ Objetivo](https://github.com/0xturazzi/Writeups/blob/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/1%20-%20Stack%20Zero.md#-objetivo)
3. [üí° Dica](https://github.com/0xturazzi/Writeups/blob/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/1%20-%20Stack%20Zero.md#-dica)
4. [üéâ Explica√ß√£o](https://github.com/0xturazzi/Writeups/blob/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/1%20-%20Stack%20Zero.md#-explica%C3%A7%C3%A3o)
5. [üëæ Solu√ß√£o](https://github.com/0xturazzi/Writeups/blob/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/1%20-%20Stack%20Zero.md#-solu√ß√£o)

# üìù Descri√ß√£o
Esse nivel demonstra que memoria pode ser acessada fora da sua regi√£o 
inicialmente alocada, como as variaveis s√£o alocadas na stack, e que altera-las pode mudar a execu√ß√£o do programa.

# üéØ Objetivo: Alterar a variavel "changeme"

# üí° Dica
```
$ python3 -c "print('A' * 10)"
AAAAAAAAAA
$ python3 -c "print('A' * 10)" | ./stack-zero 
Welcome to phoenix/stack-zero, brought to you by https://exploit.education
Uh oh, 'changeme' has not yet been changed. Would you like to try again?
```
# üéâ Explica√ß√£o
A fun√ß√£o main() pode estar sendo divida em 3 Partes:
 1. ü•û Alocando as variaveis na stack (buffer[64], changeme)
 2. üí• Alterar buffer[64] usando gets()
 3. ‚úÖ Checando se changeme foi alterada

## ü•û 1- Alocando as variaveis na stack (buffer[64], changeme)
A variavel buffer[64] tem  tamanho de 64 bytes (64 letras, assumindo ASCII).
A variavel changeme esta marcada como vol√°til para previnir que o compilador destrua ela (pq originalmente n√£o seria
alterada, ent√£o seria destruida para otimizar o c√≥digo. Mas n√≥s vamos alterar ela por metodos... n√£o convencionais hehehe).

A stack √© uma por√ß√£o da memoria que armazena como se fosse uma pilha de pratos: 
> Quando voc√™ quer colocar um novo, voc√™ coloca no topo da pilha (push)
>
> Quando voc√™ quer pegar um da pilha, voc√™ pega o do topo (pop)
>
> O ultimo a entrar, √© o primeiro a sair, o nome desse comportamento √© LIFO (Last in First Out)

![Imagem da wikipedia mostrando PUSH e POP](https://raw.githubusercontent.com/0xturazzi/Writeups/master/ExploitEducation-Phoenix-PT-BR-%20%F0%9F%87%A7%F0%9F%87%B7/img/push-pop.png)

A stack cresce para valores menores. Por exemplo:
```
Imagina que ela √© um po√ßo que come√ßa na profundidade 15
Quando voc√™ coloca algo de tamanho 2 na pilha, vai estar apoiado na profundidade 15, e vai at√© a profundidade 13
Em seguida, voc√™ coloca algo de tamanho 3, vai estar apoiado na profundidade 13, e vai at√© a profundidade 0
```
Conforme voc√™ vai **adicionando** itens, o endere√ßo que eles est√£o vai **diminuindo** em valor.
√â meio confuso, mas com o tempo voc√™ pega o jeito.

Pra complicar um pouco mais, esses endere√ßos t√£o em hexadecimal (0x0 ate 0xF, o "0x" √© pra representar que o valor t√° em hex).
Se vc n√£o souber hex: [Wikipedia Sistema de numera√ß√£o hexadecimal](https://pt.wikipedia.org/wiki/Sistema_de_numera%C3%A7%C3%A3o_hexadecimal)
. Mas resumindo, em hex voc√™ conta:
```
Hex: 0,1,2,...,8,9,A ,B ,C ,D ,E ,F ,10,11,12,...,19,1A,1B,1C,...,FF
Dec: 0,1,2,...,8,9,10,11,12,13,14,15,16,17,18,...,25,26,27,28,...,127
```
Ent√£o a base da stack √© 0xFFFFFFFF e o topo 0X00000000 !

### üåä Melhorando o exemplo do po√ßo:
```
0x0- Topo da stack/Topo do po√ßo
0xA ate 0x1- espa√ßo vazio
0xD- Segundo item
0xF- Base da stack/Fundo do po√ßo, primeiro item
```
### ‚Ü©Ô∏è Voltando ao execicio
Nossas duas variaveis (buffer[64] e changeme) s√£o empurradas na stack.
```
**Stack**
buffer[64]
changeme (com o valor: 0)
ret       - Base dessa stack
```
## üí• 2- Alterar buffer[64] usando gets
A fun√ß√£o gets() abre um input no terminal, e escreve oq recebeu em um buffer.
O problema √© que ela n√£o checa se o valor √© maior que o buffer, permitindo que 
voc√™ escreva fora do buffer.
Ela vai come√ßar a escrever no topo do buffer (menor endere√ßo) e vai descendo at√© a base da stack.
Nesse caso, alteraria o valor de "changeme"
```
**Stack**
buffer
       [
A           | Gets escreve nesse sentido
A           |
A           \/
...
A
      ]
ret       - Base dessa stack
```
ent√£o, caso colocassemos 100 "A"s no buffer de tamanho 64, as variaveis nos proximos 36 endere√ßos seriam alteradas.
Essas variaveis ficariam com o valor "41", mas pq 41? O valor ASCII do "A" √© 0x41, voc√™ pode checar o de todas letras usando:
> $ man ascii

Ui, o usuario arbitrariamente manipular memoria, perigoso ne? D:
√â por isso que essa fun√ß√£o est√° marcada como _Deprecated_ (fora de uso).

No nosso caso, o buffer tem o tamanho de **64** bytes, se colocarmos **65** "A"s (65 bytes), o valor vai vazar desse buffer.
Isso quer dizer que antes a variavel changeme tinha o valor "0x00" e agora tem o valor "0x41" !
```
**Stack**
buffer
      [
41           | Gets escreve nesse sentido
41           |
41           \/
...
41
      ]
changeme (com o valor: 41)
ret       - Base dessa stack
```
## ‚úÖ 3- O programa checa se changeme foi alterada
Se foi alterada, quer dizer que a gente _overflow-ou_ o buffer, √© vitoria!!! :D

Ta, mas como a gente faz isso na pr√°tica?
`python3 -c "print("A"*65)"` printa 65 "A"s
Ent√£o se a gente encaminhar esses "A"s pro programa....
Se voc√™ quer tentar resolver sozinhe, agora √© a sua hora!

.
.
.
.

### ‚ùå 64 As, changeme n√£o alterado
```
user@phoenix-amd64:/opt/phoenix/amd64$ python3 -c "print('A' * 64)" | ./stack-zero 
Welcome to phoenix/stack-zero, brought to you by https://exploit.education
Uh oh, 'changeme' has not yet been changed. Would you like to try again?
```
### ‚úÖ 65 As, changeme alterado
```
user@phoenix-amd64:/opt/phoenix/amd64$ python3 -c "print('A' * 65)" | ./stack-zero 
Welcome to phoenix/stack-zero, brought to you by https://exploit.education
Well done, the 'changeme' variable has been changed!
```

Para demonstrar melhor esse comportamento do buffer ser escrito em um sentido espec√≠fico (pq vai ser muito importante saber disso), vou dar outro exemplo:
`python3 -c "print('A' * 64 + 'B')" | ./stack-zero` 

### üÖ±Ô∏è 64 As e um B (0x42): AAAAAAAAA.....AAAB
```
**Stack**
buffer
      [
41           | Gets escreve nesse sentido
41           |
41           \/
...
41
      ]
changeme (com o valor: **42**)
ret       - Base dessa stack
```
Os As preenchem certinho a stack, e a gente pode colocar o valor que quiser na variavel!! Uhhuuu :D
Esses As s√≥ pra encher a stack s√£o chamados de "padding" (traduz pra preenchimento).

Fim! :D

Ouch... isso foi um bocado de explica√ß√£o, mas relaxa que daqui pra frente fica mais dificil hehehe :D
Se voc√™ chegou at√© aqui, voc√™ ta de parabens !!!
Tira um tempinho pra descansar a cabe√ßa que isso foi beeeem abstrato...
Pra lembrar bem, desenha uma stack no papel, da um push nas variaveis e no buffer, mostra o sentido que o 
buffer escreve, e ele vazando e mudando o valor das outras variaveis...


# üëæ Solu√ß√£o
```
python3 -c "print('A' * 65)" | ./stack-zero
Welcome to phoenix/stack-zero, brought to you by https://exploit.education
Well done, the 'changeme' variable has been changed!
```
